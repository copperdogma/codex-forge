<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pipeline Visibility — codex-forge</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css">
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #131821;
      --panel-2: #182030;
      --accent: #4ad7b2;
      --accent-2: #f5a524;
      --text: #f4f7fb;
      --muted: #8ea0b8;
      --danger: #ff6b6b;
      --grid: 280px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(120% 120% at 20% 20%, rgba(74,215,178,0.08), transparent),
                  radial-gradient(120% 120% at 80% 0%, rgba(245,165,36,0.08), transparent),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 20px 32px 40px;
    }
    header {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 18px;
    }
    h1 {
      margin: 0;
      font-size: 26px;
      letter-spacing: -0.01em;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 999px;
      font-size: 13px;
      color: var(--muted);
    }
    .pill strong { color: var(--text); font-weight: 600; }

    .controls {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 14px;
      padding: 14px 16px;
      display: grid;
      grid-template-columns: 2fr 1fr 1fr auto;
      gap: 12px;
      align-items: center;
      box-shadow: 0 18px 40px rgba(0,0,0,0.25);
    }
    .controls label { font-size: 12px; text-transform: uppercase; color: var(--muted); letter-spacing: 0.05em; }
    .controls input, .controls select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.07);
      background: var(--panel-2);
      color: var(--text);
      font-family: "Space Grotesk", sans-serif;
    }
    .controls button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(135deg, var(--accent), #2ebd9c);
      color: #041115;
      font-weight: 700;
      cursor: pointer;
      letter-spacing: 0.01em;
    }
    .controls button.secondary {
      background: rgba(255,255,255,0.08);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.08);
    }

    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(var(--grid), 1fr)); gap: 14px; margin-top: 16px; }
    .card {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 14px 30px rgba(0,0,0,0.2);
    }
    .card-header { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .elapsed { font-size: 12px; color: var(--muted); }
    .elapsed.running { color: var(--accent); }
    .card h3 { margin: 0 0 6px; font-size: 16px; letter-spacing: -0.01em; }
    .meta { display: flex; gap: 10px; flex-wrap: wrap; font-size: 12px; color: var(--muted); }
    .progress-bar {
      position: relative;
      height: 10px;
      width: 100%;
      background: rgba(255,255,255,0.05);
      border-radius: 999px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-bar span {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      background: linear-gradient(90deg, var(--accent), #6cf0ca);
      border-radius: 999px;
    }
    .status { font-size: 13px; font-weight: 600; }
    .status.running { color: var(--accent); }
    .status.done { color: #8fe3ff; }
    .status.failed { color: var(--danger); }
    .status.skipped { color: var(--muted); }
    .chips { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .chip {
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      color: var(--muted);
    }
    .chip strong { color: var(--text); }
    .timeline { margin-top: 18px; }
    .timeline ul { list-style: none; padding: 0; margin: 0; }
    .timeline li { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); display: grid; grid-template-columns: 160px 90px 1fr; gap: 10px; align-items: center; }
    .mono { font-family: "IBM Plex Mono", monospace; font-size: 12px; color: var(--muted); }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .badge.success { background: rgba(106, 255, 215, 0.16); color: #7bf3cc; border: 1px solid rgba(106,255,215,0.3); }
    .badge.warn { background: rgba(245,165,36,0.14); color: #f5c36a; border: 1px solid rgba(245,165,36,0.3); }
    .badge.danger { background: rgba(255,107,107,0.18); color: #ff9f9f; border: 1px solid rgba(255,107,107,0.3); }
    .badge.muted { background: rgba(255,255,255,0.08); color: var(--muted); border: 1px solid rgba(255,255,255,0.08); }
    .footer { margin-top: 16px; color: var(--muted); font-size: 12px; }
    .artifact-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .btn-small {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      cursor: pointer;
      font-size: 12px;
    }
    .metrics { margin-top: 6px; font-size: 12px; color: var(--muted); }
    pre {
      background: #0d1219;
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 12px;
      overflow: auto;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      max-height: 320px;
    }
    .layout { display: grid; grid-template-columns: 1fr 0 0; gap: 0; transition: grid-template-columns 0.2s ease; }
    #split-handle { width: 0; cursor: col-resize; background: rgba(255,255,255,0.06); }
    #pane-col { overflow: auto; display: flex; flex-direction: column; }
    #artifact-preview { flex: 1; }
    .pane-header { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .pane-actions { display: flex; gap: 6px; }
    pre code.hljs { display: block; }
    @media (max-width: 1100px) { .layout { grid-template-columns: 1fr 0 0; } #pane-col { position: sticky; top: 10px; } }
    @media (max-width: 900px) {
      .controls { grid-template-columns: 1fr; }
      .timeline li { grid-template-columns: 120px 70px 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Pipeline Visibility</h1>
      <div class="pill">Live view of <strong>pipeline_state.json</strong> + events</div>
    </div>
    <div class="pill mono" id="last-refresh">—</div>
  </header>

  <section class="controls">
    <div>
      <label for="run-select">Run</label>
      <select id="run-select"></select>
    </div>
    <div>
      <label for="manual-run">Manual Run ID</label>
      <input id="manual-run" placeholder="e.g., deathtrap-text-ingest" />
    </div>
    <div>
      <label for="refresh-ms">Refresh (ms)</label>
      <input type="number" id="refresh-ms" value="4000" min="1000" step="500" />
    </div>
    <div style="display:flex; gap:8px;">
      <button id="load-btn">Load</button>
      <button class="secondary" id="toggle-auto">Pause Auto</button>
    </div>
  </section>

  <div class="layout" id="layout">
    <div id="main-col">
      <section class="grid" id="summary-grid"></section>
      <section class="grid" id="stage-grid"></section>
      <section class="card timeline">
        <h3>Recent Events</h3>
        <ul id="timeline-list"></ul>
      </section>
    </div>
    <div id="split-handle" title="Drag to resize"></div>
    <aside class="card" id="pane-col" style="display:none;">
      <div class="pane-header">
        <h3>Artifact Pane</h3>
        <div class="pane-actions">
          <button class="btn-small" id="pane-open-tab">Open in new tab</button>
          <button class="btn-small" id="pane-close">Close</button>
        </div>
      </div>
      <div class="meta" id="artifact-meta"></div>
      <pre id="artifact-preview"></pre>
    </aside>
  </div>

  <div class="footer">
    Serve this file from the repo root (e.g., <code>python -m http.server 8000</code>) then open <code>/docs/pipeline-visibility.html</code>.
    The viewer polls <code>pipeline_state.json</code> and <code>pipeline_events.jsonl</code> inside <code>output/runs/&lt;run_id&gt;/</code>.
  </div>

  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/json.min.js"></script>
  <script>
    const ROOT = window.location.pathname.includes("/docs/") ? ".." : ".";
    const runSelect = document.getElementById("run-select");
    const manualRun = document.getElementById("manual-run");
    const loadBtn = document.getElementById("load-btn");
    const toggleAuto = document.getElementById("toggle-auto");
    const refreshInput = document.getElementById("refresh-ms");
    const lastRefresh = document.getElementById("last-refresh");
    const summaryGrid = document.getElementById("summary-grid");
    const stageGrid = document.getElementById("stage-grid");
    const timelineList = document.getElementById("timeline-list");
    const layout = document.getElementById("layout");
    const mainCol = document.getElementById("main-col");
    const splitHandle = document.getElementById("split-handle");
    const artifactPanel = document.getElementById("pane-col");
    const artifactMeta = document.getElementById("artifact-meta");
    const artifactPreview = document.getElementById("artifact-preview");
    const paneClose = document.getElementById("pane-close");
    const paneOpenTab = document.getElementById("pane-open-tab");

    let currentRun = null;
    let userSelectedRun = false;
    let autoTimer = null;
    const artifactCache = {};
    const instCache = {};
    const runMeta = {};

    const statusDescriptors = {
      "running": { text: "Running", class: "running" },
      "done": { text: "Done", class: "done" },
      "failed": { text: "Failed", class: "failed" },
      "skipped": { text: "Skipped", class: "skipped" },
      "queued": { text: "Queued", class: "muted" }
    };

    function escapeHtml(str) {
      return str.replace(/[&<>'"]/g, c => ({"&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;"}[c]));
    }

    function renderPretty(text, lang = "json") {
      const code = document.createElement("code");
      code.className = `language-${lang}`;
      code.textContent = text; // safer than innerHTML
      artifactPreview.innerHTML = "";
      const pre = document.createElement("pre");
      pre.appendChild(code);
      artifactPreview.appendChild(pre);
      if (window.hljs) {
        try { hljs.highlightElement(code); } catch (e) { /* no-op */ }
      }
    }

    function openPane() {
      artifactPanel.style.display = "block";
      layout.style.gridTemplateColumns = "1fr 6px min(45vw, 640px)";
      splitHandle.style.width = "6px";
    }

    function closePane() {
      artifactPanel.style.display = "none";
      layout.style.gridTemplateColumns = "1fr 0 0";
      splitHandle.style.width = "0";
    }

    paneClose.onclick = () => closePane();
    paneOpenTab.onclick = () => {
      const path = paneOpenTab.dataset.path;
      const stage = paneOpenTab.dataset.stage;
      if (path) openArtifactTab(stage || "", path);
    };

    let dragging = false;
    splitHandle.addEventListener("mousedown", () => { dragging = true; });
    window.addEventListener("mouseup", () => { dragging = false; });
    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const total = layout.getBoundingClientRect();
      const mainWidth = e.clientX - total.left;
      const paneWidth = Math.max(280, total.width - mainWidth - 6);
      layout.style.gridTemplateColumns = `${Math.max(320, mainWidth)}px 6px ${paneWidth}px`;
    });

    function parseJSONL(text) {
      return text.split("\n").filter(Boolean).map(line => {
        try { return JSON.parse(line); } catch { return null; }
      }).filter(Boolean);
    }

    async function fetchJSON(path) {
      const res = await fetch(path + "?t=" + Date.now());
      if (!res.ok) throw new Error(`Fetch failed: ${path}`);
      return res.json();
    }
    async function fetchJSONL(path) {
      const res = await fetch(path + "?t=" + Date.now());
      if (!res.ok) throw new Error(`Fetch failed: ${path}`);
      const text = await res.text();
      return parseJSONL(text);
    }

    function parseTimestamp(val) {
      if (!val) return 0;
      // Trim fractional seconds to 3 digits for JS Date.parse compatibility
      const fixed = val.replace(/\\.(\\d{3})\\d+Z$/, ".$1Z");
      const ts = Date.parse(fixed);
      return isNaN(ts) ? 0 : ts;
    }

    async function loadManifest() {
      const manifestPath = `${ROOT}/output/run_manifest.jsonl`;
      try {
        const res = await fetch(manifestPath);
        if (!res.ok) throw new Error();
        const lines = parseJSONL(await res.text());
        runSelect.innerHTML = "";

        const candidates = lines.slice(-150); // last N entries

        async function resolveTs(row) {
          const direct = parseTimestamp(row.created_at || row.updated_at || "");
          if (direct) return direct;
          if (!row.path) return 0;
          try {
            const state = await fetchJSON(`${ROOT}/${row.path}/pipeline_state.json`);
            let ts = parseTimestamp(state.updated_at || state.created_at || state.timestamp || "");
            if (!ts && state.stages) {
              const stageTimes = Object.values(state.stages).map(s => parseTimestamp(s.updated_at));
              const maxStage = Math.max(0, ...stageTimes.filter(Boolean));
              ts = maxStage;
            }
            return ts;
          } catch {
            return 0;
          }
        }

        const withTs = await Promise.all(candidates.map(async (row) => ({
          row,
          ts: await resolveTs(row),
        })));

        const sorted = withTs.sort((a, b) => (b.ts || 0) - (a.ts || 0)).map(x => x.row);

        // reverse for display so newest is first in dropdown
        sorted.forEach(row => {
          runMeta[row.run_id] = row;
          const opt = document.createElement("option");
          opt.value = row.run_id;
          opt.textContent = `${row.run_id} — ${row.input?.pdf || row.path}`;
          runSelect.appendChild(opt);
        });
        const currentExists = sorted.some(r => r.run_id === currentRun);
        if (!userSelectedRun || !currentExists) {
          currentRun = sorted.length ? sorted[0].run_id : null; // newest
        }
        if (currentRun) runSelect.value = currentRun;
        lastRefresh.textContent = `Manifest: ${manifestPath}`;
      } catch {
        runSelect.innerHTML = "";
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No manifest found (add run manually)";
        runSelect.appendChild(opt);
      }
    }

    function percentText(p) {
      if (p === null || p === undefined) return "—";
      return `${p}%`;
    }

    function formatDuration(seconds) {
      if (seconds == null || isNaN(seconds) || seconds < 0) return "—";
      if (seconds < 1) return "<1s";
      const s = Math.floor(seconds % 60);
      const m = Math.floor((seconds / 60) % 60);
      const h = Math.floor(seconds / 3600);
      if (h) return `${h}h ${m.toString().padStart(2,"0")}m`;
      return `${m}:${s.toString().padStart(2,"0")}s`;
    }

    function computeStageDurations(events, stages) {
      const map = {};
      events.forEach(evt => {
        const ts = parseTimestamp(evt.timestamp);
        if (!ts || !evt.stage) return;
        const entry = map[evt.stage] || { start: null, end: null, lastStatus: evt.status };
        if (entry.start === null || ts < entry.start) entry.start = ts;
        if (entry.end === null || ts > entry.end) entry.end = ts;
        entry.lastStatus = evt.status || entry.lastStatus;
        map[evt.stage] = entry;
      });
      // fallbacks from state updated_at when no events
      Object.entries(stages || {}).forEach(([stage, info]) => {
        if (map[stage]) return;
        const ts = parseTimestamp(info.updated_at);
        if (ts) map[stage] = { start: ts, end: ts, lastStatus: info.status };
      });
      return map;
    }

    function summariseStages(stages) {
      const entries = Object.entries(stages || {});
      const done = entries.filter(([, s]) => s.status === "done").length;
      const failed = entries.filter(([, s]) => s.status === "failed").length;
      const running = entries.filter(([, s]) => s.status === "running").length;
      const percents = entries.map(([, s]) => (s.progress && s.progress.percent != null ? s.progress.percent : (s.status === "done" ? 100 : 0)));
      const avg = percents.length ? Math.round(percents.reduce((a, b) => a + b, 0) / percents.length) : 0;
      return { done, failed, running, avg, total: entries.length };
    }

    function badge(status) {
      const span = document.createElement("span");
      const desc = statusDescriptors[status] || { text: status || "unknown", class: "muted" };
      span.className = `badge ${desc.class}`;
      span.textContent = desc.text.toUpperCase();
      return span;
    }

    async function loadRun(runId) {
      if (!runId) return;
      currentRun = runId;
      const meta = runMeta[runId] || {};
      const base = meta.path ? `${ROOT}/${meta.path}` : `${ROOT}/output/runs/${runId}`;
      try {
        const instPath = meta.instrumentation?.json
          ? `${ROOT}/${meta.instrumentation.json}`
          : `${base}/instrumentation.json`;
        const [state, events, instrumentation] = await Promise.all([
          fetchJSON(`${base}/pipeline_state.json`),
          fetchJSONL(`${base}/pipeline_events.jsonl`).catch(() => []),
          fetchJSON(instPath).catch(() => null)
        ]);
        if (instrumentation) instCache[runId] = instrumentation;
        render(state, events, base, instCache[runId]);
        lastRefresh.textContent = `Updated ${new Date().toLocaleTimeString()}`;
      } catch (e) {
        stageGrid.innerHTML = "";
        summaryGrid.innerHTML = "";
        timelineList.innerHTML = `<li class="mono">Unable to load run "${runId}". Check that output/runs/${runId}/pipeline_state.json exists.</li>`;
      }
    }

    function render(state, events, base, instrumentation) {
      const stages = state.stages || {};
      const stats = summariseStages(stages);

      summaryGrid.innerHTML = "";
      summaryGrid.appendChild(makeStatCard("Overall Progress", `${stats.avg}%`, [
        `${stats.done}/${stats.total} done`,
        `${stats.running} running`,
        `${stats.failed} failed`
      ]));
      summaryGrid.appendChild(makeStatCard("Run", state.run_id || currentRun || "n/a", [
        state.updated_at ? `updated ${state.updated_at}` : "live",
        base.replace(`${ROOT}/`, "")
      ]));
      summaryGrid.appendChild(makeStatCard("Artifacts", "", [
        "Click any stage to open artifacts",
        "Auto-refresh uses pipeline_events.jsonl"
      ]));
      const meta = runMeta[state.run_id || currentRun] || {};
      const inst = document.createElement("div");
      inst.className = "card";
      inst.innerHTML = `<h3>Instrumentation</h3>`;
      const links = document.createElement("div");
      links.className = "meta";
      if (meta.instrumentation?.json) {
        const a = document.createElement("a");
        a.href = `${ROOT}/${meta.instrumentation.json}`;
        a.target = "_blank";
        a.textContent = "JSON report";
        links.appendChild(a);
      }
      if (meta.instrumentation?.md) {
        const a = document.createElement("a");
        a.href = `${ROOT}/${meta.instrumentation.md}`;
        a.target = "_blank";
        a.textContent = "Markdown summary";
        links.appendChild(a);
      }
      if (instrumentation) {
        const totals = instrumentation.totals || {};
        const perModel = totals.per_model || {};
        const models = Object.entries(perModel).sort((a, b) => (b[1].cost || 0) - (a[1].cost || 0)).slice(0, 3);
        const stats = document.createElement("div");
        stats.className = "meta";
        stats.innerHTML = `
          <span>Total cost: ${(totals.cost || 0).toFixed(4)} ${(instrumentation.pricing?.currency) || "USD"}</span>
          <span>Calls: ${totals.calls || 0}</span>
          <span>Tokens: ${totals.prompt_tokens || 0} / ${totals.completion_tokens || 0}</span>
        `;
        inst.appendChild(stats);
        if (models.length) {
          const top = document.createElement("div");
          top.className = "meta";
          top.innerHTML = `<span>Top models:</span>${models.map(([m,v]) => `<span>${m}: ${(v.cost||0).toFixed(4)}</span>`).join("")}`;
          inst.appendChild(top);
        }
      } else {
        const msg = document.createElement("div");
        msg.className = "meta";
        msg.innerHTML = "<span>Instrumentation data not found for this run.</span>";
        inst.appendChild(msg);
      }
      if (links.children.length) inst.appendChild(links);
      summaryGrid.appendChild(inst);

      const durations = computeStageDurations(events, stages);
      renderStages(stages, events, base, instrumentation, durations);
      renderTimeline(events);
    }

    function makeStatCard(title, value, lines) {
      const card = document.createElement("div");
      card.className = "card";
      card.innerHTML = `<h3>${title}</h3><div class="status done" style="font-size:24px;">${value}</div>`;
      if (lines?.length) {
        const ul = document.createElement("div");
        ul.className = "meta";
        lines.forEach(l => {
          const span = document.createElement("span");
          span.textContent = l;
          ul.appendChild(span);
        });
        card.appendChild(ul);
      }
      return card;
    }

    function renderStages(stages, events, base, instrumentation, durations) {
      stageGrid.innerHTML = "";
      const instMap = {};
      if (instrumentation?.stages) {
        instrumentation.stages.forEach(s => { if (s.id) instMap[s.id] = s; });
      }
      const ordered = Object.keys(stages).sort();
      ordered.forEach(stage => {
        const info = stages[stage];
        const card = document.createElement("div");
        card.className = "card";
        const status = info.status || "queued";
        const prog = info.progress || {};
        const timing = durations?.[stage] || {};
        let elapsedText = "—";
        if (timing.start) {
          if (status === "running") {
            elapsedText = `▶ ${formatDuration((Date.now() - timing.start) / 1000)}`;
          } else if (timing.end) {
            elapsedText = `⏱ ${formatDuration((timing.end - timing.start) / 1000)}`;
          }
        }
        card.innerHTML = `
          <div class="card-header">
            <h3>${stage}</h3>
            <div class="elapsed ${status === "running" ? "running" : ""}">${elapsedText}</div>
          </div>
          <div class="status ${statusDescriptors[status]?.class || ""}">${status.toUpperCase()}</div>
          <div class="progress-bar"><span style="width:${Math.min(100, prog.percent || (status === "done" ? 100 : 0))}%"></span></div>
          <div class="meta">
            <span>${prog.current ?? "—"} / ${prog.total ?? "?"}</span>
            <span>${percentText(prog.percent)}</span>
            <span>${info.updated_at || ""}</span>
          </div>
        `;

        const chips = document.createElement("div");
        chips.className = "chips";
        if (info.artifact) {
          const name = info.artifact.split("/").slice(-1)[0];
          const artChip = document.createElement("div");
          artChip.className = "chip";
          artChip.innerHTML = `<strong>Artifact</strong> ${name}`;
          chips.appendChild(artChip);
        }
        if (info.module_id) {
          const mod = document.createElement("div");
          mod.className = "chip";
          mod.innerHTML = `<strong>Module</strong> ${info.module_id}`;
          chips.appendChild(mod);
        }
        if (info.schema_version) {
          const sch = document.createElement("div");
          sch.className = "chip";
          sch.innerHTML = `<strong>Schema</strong> ${info.schema_version}`;
          chips.appendChild(sch);
        }
        const inst = instMap[stage];
        const costVal = inst?.llm_totals?.cost || 0;
        const costChip = document.createElement("div");
        costChip.className = "chip";
        costChip.title = costVal === 0 ? "No LLM calls recorded for this stage (non-LLM step or module emitted no usage)" : "";
        costChip.innerHTML = `<strong>Cost</strong> ${costVal.toFixed(4)}`;
        chips.appendChild(costChip);
        if (inst && inst.wall_seconds != null) {
            const timeChip = document.createElement("div");
            timeChip.className = "chip";
            timeChip.innerHTML = `<strong>Wall</strong> ${inst.wall_seconds.toFixed(2)}s`;
            chips.appendChild(timeChip);
        }
        card.appendChild(chips);

        const actions = document.createElement("div");
        actions.className = "artifact-actions";
        if (info.artifact) {
          const open = document.createElement("button");
          open.className = "btn-small";
          open.textContent = "Open artifact (new tab)";
          open.onclick = () => openArtifactTab(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(open);

          const viewBtn = document.createElement("button");
          viewBtn.className = "btn-small";
          viewBtn.textContent = "View in pane";
          viewBtn.onclick = () => viewArtifact(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(viewBtn);

          const metricsBtn = document.createElement("button");
          metricsBtn.className = "btn-small";
          metricsBtn.textContent = "Load metrics";
          metricsBtn.onclick = () => loadMetrics(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(metricsBtn);
        }
        const history = events.filter(e => e.stage === stage);
        if (history.length) {
          const last = history[history.length - 1];
          const hint = document.createElement("div");
          hint.className = "metrics";
          hint.textContent = `${history.length} events | last: ${last.status} @ ${last.timestamp}`;
          actions.appendChild(hint);
        }
        card.appendChild(actions);
        stageGrid.appendChild(card);
      });
    }

    function renderTimeline(events) {
      timelineList.innerHTML = "";
      const recent = events.slice(-80).reverse();
      if (!recent.length) {
        timelineList.innerHTML = `<li class="mono">No events yet for this run.</li>`;
        return;
      }
      recent.forEach(evt => {
        const li = document.createElement("li");
        const badgeEl = badge(evt.status);
        const stage = document.createElement("div");
        stage.innerHTML = `<strong>${evt.stage}</strong><br><span class="mono">${evt.timestamp}</span>`;
        const prog = evt.percent != null ? `${evt.current || "?"}/${evt.total || "?"} (${evt.percent}%)` : "";
        const msg = document.createElement("div");
        msg.innerHTML = `<div class="mono">${prog}</div><div>${evt.message || ""}</div>`;
        const col1 = document.createElement("div");
        col1.appendChild(stage);
        const col2 = document.createElement("div");
        col2.appendChild(badgeEl);
        li.appendChild(stage);
        li.appendChild(col2);
        li.appendChild(msg);
        timelineList.appendChild(li);
      });
    }

    async function loadMetrics(stage, artifactPath) {
      openPane();
      artifactMeta.innerHTML = "";
      artifactPreview.textContent = "Loading…";
      paneOpenTab.dataset.path = artifactPath;
      paneOpenTab.dataset.stage = stage;

      if (artifactCache[artifactPath]) {
        renderMetrics(stage, artifactPath, artifactCache[artifactPath]);
        return;
      }

      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();
        let rows = [];
        if (artifactPath.endsWith(".jsonl")) {
          rows = parseJSONL(text);
        } else if (artifactPath.endsWith(".json")) {
          rows = Object.values(JSON.parse(text));
        }
        const confidences = rows.map(r => r.confidence).filter(v => v !== undefined && v !== null);
        const avg = confidences.length ? (confidences.reduce((a,b)=>a+b,0)/confidences.length).toFixed(3) : "n/a";
        const min = confidences.length ? Math.min(...confidences).toFixed(3) : "n/a";
        const max = confidences.length ? Math.max(...confidences).toFixed(3) : "n/a";
        const sample = rows.slice(0, 3);
        const metrics = { count: rows.length, avg, min, max, sample };
        artifactCache[artifactPath] = metrics;
        renderMetrics(stage, artifactPath, metrics);
      } catch (e) {
        artifactPreview.textContent = `Failed to load artifact: ${e.message}`;
      }
    }

    async function openArtifactTab(stage, artifactPath) {
      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();
        const pretty = formatMaybeJSON(text, artifactPath);
        const html = `<!DOCTYPE html><html><head><link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css\"><script src=\"https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js\"><\/script><script src=\"https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/json.min.js\"><\/script></head><body style=\"margin:0;background:#0d1219;color:#e5e9f0;\"><pre><code class=\"language-json\">${escapeHtml(pretty)}</code></pre><script>window.hljs&&hljs.highlightAll();<\/script></body></html>`;
        const blob = new Blob([html], { type: "text/html;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        window.open(url, "_blank");
      } catch (e) {
        alert(`Failed to open artifact: ${e.message}`);
      }
    }

    function formatMaybeJSON(text, artifactPath) {
      try {
        if (artifactPath.endsWith(".jsonl")) {
          const rows = parseJSONL(text);
          return JSON.stringify(rows, null, 2);
        }
        if (artifactPath.endsWith(".json")) {
          return JSON.stringify(JSON.parse(text), null, 2);
        }
      } catch (e) {
        // fall through to raw text
      }
      return text;
    }

    function getStageInstrumentation(stage) {
      const inst = instCache[currentRun];
      if (!inst?.stages) return null;
      return inst.stages.find(s => s.id === stage);
    }

    async function viewArtifact(stage, artifactPath) {
      openPane();
      artifactPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      const inst = getStageInstrumentation(stage);
      const chips = [
        `<div class="chip"><strong>Stage</strong> ${stage}</div>`,
        `<div class="chip"><strong>Path</strong> ${artifactPath}</div>`
      ];
      if (inst) {
        chips.push(`<div class="chip"><strong>Cost</strong> ${(inst.llm_totals?.cost || 0).toFixed(4)}</div>`);
        chips.push(`<div class="chip"><strong>Calls</strong> ${inst.llm_totals?.calls || 0}</div>`);
        chips.push(`<div class="chip"><strong>Tokens</strong> ${inst.llm_totals?.prompt_tokens || 0}/${inst.llm_totals?.completion_tokens || 0}</div>`);
        if (inst.wall_seconds != null) {
          chips.push(`<div class="chip"><strong>Wall</strong> ${inst.wall_seconds.toFixed(2)}s</div>`);
        }
      } else {
        chips.push(`<div class="chip"><strong>Instrumentation</strong> not available</div>`);
      }
      artifactMeta.innerHTML = chips.join("");
      artifactPreview.textContent = "Loading artifact…";
      paneOpenTab.dataset.path = artifactPath;
      paneOpenTab.dataset.stage = stage;

      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();
        let parsed;
        if (artifactPath.endsWith(".jsonl")) {
          parsed = parseJSONL(text);
        } else if (artifactPath.endsWith(".json")) {
          parsed = JSON.parse(text);
        } else {
          parsed = text;
        }

        const MAX_ROWS = 200;
        let displayVal = parsed;
        let clipped = false;
        if (Array.isArray(parsed) && parsed.length > MAX_ROWS) {
          displayVal = parsed.slice(0, MAX_ROWS);
          clipped = true;
        }
        const pretty = typeof displayVal === "string" ? displayVal : JSON.stringify(displayVal, null, 2);
        renderPretty(pretty, "json");
        if (clipped) {
          artifactPreview.innerHTML += `<div class="mono">… clipped to first ${MAX_ROWS} records …</div>`;
        }
      } catch (e) {
        artifactPanel.style.display = "block";
        artifactPreview.textContent = `Failed to load artifact: ${e.message}`;
      }
    }

    function renderMetrics(stage, artifactPath, metrics) {
      artifactMeta.innerHTML = `
        <div class="chip"><strong>Stage</strong> ${stage}</div>
        <div class="chip"><strong>Records</strong> ${metrics.count}</div>
        <div class="chip"><strong>Confidence</strong> avg ${metrics.avg}, min ${metrics.min}, max ${metrics.max}</div>
        <div class="chip"><strong>Path</strong> ${artifactPath}</div>
      `;
      renderPretty(JSON.stringify(metrics.sample, null, 2), "json");
    }

    function startAuto() {
      stopAuto();
      const ms = Number(refreshInput.value) || 4000;
      autoTimer = setInterval(() => {
        if (currentRun) loadRun(currentRun);
      }, ms);
      toggleAuto.textContent = "Pause Auto";
    }
    function stopAuto() {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = null;
      toggleAuto.textContent = "Resume Auto";
    }

    loadBtn.onclick = () => {
      const chosen = manualRun.value || runSelect.value;
      loadRun(chosen);
      startAuto();
    };
    runSelect.onchange = () => {
      userSelectedRun = true;
      loadRun(runSelect.value);
    };
    toggleAuto.onclick = () => {
      if (autoTimer) stopAuto(); else startAuto();
    };

    loadManifest().then(() => {
      if (currentRun) {
        loadRun(currentRun);
      }
      startAuto();
    });
  </script>
</body>
</html>
