<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pipeline Visibility — codex-forge</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=IBM+Plex+Mono:wght@400;600&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/markdown.min.js"></script>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #131821;
      --panel-2: #182030;
      --accent: #4ad7b2;
      --accent-2: #f5a524;
      --text: #f4f7fb;
      --muted: #8ea0b8;
      --danger: #ff6b6b;
      --grid: 280px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(120% 120% at 20% 20%, rgba(74, 215, 178, 0.08), transparent),
        radial-gradient(120% 120% at 80% 0%, rgba(245, 165, 36, 0.08), transparent),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 20px 32px 0;
    }

    header {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 18px;
    }

    h1 {
      margin: 0;
      font-size: 26px;
      letter-spacing: -0.01em;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    h1:hover {
      opacity: 0.7;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      font-size: 13px;
      color: var(--muted);
    }

    .pill strong {
      color: var(--text);
      font-weight: 600;
    }

    .controls {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 14px;
      padding: 14px 16px;
      display: grid;
      grid-template-columns: 2fr 1fr 1fr auto;
      gap: 12px;
      align-items: end;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.25);
    }

    .controls label {
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.05em;
    }

    .controls input,
    .controls select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.07);
      background: var(--panel-2);
      color: var(--text);
      font-family: "Space Grotesk", sans-serif;
    }

    .controls button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(135deg, var(--accent), #2ebd9c);
      color: #041115;
      font-weight: 700;
      cursor: pointer;
      letter-spacing: 0.01em;
    }

    .controls button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .run-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .run-row select,
    .run-row .run-select {
      flex: 1;
    }

    .run-select {
      position: relative;
      width: 100%;
    }

    .run-select button {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.07);
      background: var(--panel-2);
      color: var(--text);
      font-family: "Space Grotesk", sans-serif;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .run-select button .label {
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .run-select button .chev {
      opacity: 0.6;
    }

    .run-popover {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
      padding: 10px;
      z-index: 200;
      display: none;
    }

    .run-popover.open {
      display: block;
    }

    .run-filter {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: var(--panel-2);
      color: var(--text);
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      margin-bottom: 8px;
    }

    .run-options {
      max-height: 320px;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .run-option {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.02);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .run-option:hover {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.05);
    }

    .run-option.active {
      border-color: rgba(74, 215, 178, 0.6);
      box-shadow: 0 0 0 1px rgba(74, 215, 178, 0.3) inset;
    }

    .run-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
      font-weight: 600;
    }

    .run-meta {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 11px;
      color: var(--muted);
    }

    .status-pill {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .status-pill.running {
      background: rgba(74, 215, 178, 0.16);
      color: #7bf3cc;
      border: 1px solid rgba(74, 215, 178, 0.4);
    }

    .status-pill.done {
      background: rgba(143, 227, 255, 0.16);
      color: #8fe3ff;
      border: 1px solid rgba(143, 227, 255, 0.35);
    }

    .status-pill.failed {
      background: rgba(255, 107, 107, 0.16);
      color: #ff9f9f;
      border: 1px solid rgba(255, 107, 107, 0.35);
    }

    .status-pill.crashed {
      background: rgba(255, 107, 107, 0.16);
      color: #ff9f9f;
      border: 1px solid rgba(255, 107, 107, 0.35);
    }

    .status-pill.queued,
    .status-pill.unknown {
      background: rgba(255, 255, 255, 0.08);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .control-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.07);
      background: var(--panel-2);
      color: var(--muted);
      font-size: 12px;
    }

    .control-toggle input {
      accent-color: var(--accent);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(var(--grid), 1fr));
      gap: 14px;
      margin-top: 16px;
    }

    .card {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .stage-card {
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
      padding-bottom: 42px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .stage-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .stage-name {
      font-weight: 600;
      font-size: 15px;
    }

    .stage-time {
      font-size: 12px;
      color: var(--muted);
      font-family: "IBM Plex Mono", monospace;
    }

    .elapsed {
      font-size: 12px;
      color: var(--muted);
    }

    .elapsed.running {
      color: var(--accent);
    }

    .card h3 {
      margin: 0;
      font-size: 16px;
      letter-spacing: -0.01em;
    }

    .meta {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--muted);
    }

    .progress-bar {
      position: relative;
      height: 10px;
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 999px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-bar span {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      background: linear-gradient(90deg, var(--accent), #6cf0ca);
      border-radius: 999px;
    }

    .status {
      font-size: 13px;
      font-weight: 600;
    }

    .status-pill.big {
      font-size: 11px;
      padding: 4px 10px;
    }

    .status.running {
      color: var(--accent);
    }

    .status.done {
      color: #8fe3ff;
    }

    .status.failed {
      color: var(--danger);
    }

    .status.crashed {
      color: var(--danger);
    }

    .status.skipped {
      color: var(--muted);
    }

    .chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .cost-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .cost-table th,
    .cost-table td {
      text-align: left;
      padding: 8px 6px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      vertical-align: top;
    }

    .cost-table th {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
    }

    .cost-name {
      font-weight: 600;
    }

    .cost-sub {
      font-size: 11px;
      color: var(--muted);
      font-family: "IBM Plex Mono", monospace;
      margin-top: 2px;
    }

    .cost-value {
      font-family: "IBM Plex Mono", monospace;
    }

    .chip {
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 12px;
      color: var(--muted);
    }

    .chip strong {
      color: var(--text);
    }

    .timeline {
      margin-top: 18px;
    }

    .timeline ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .timeline li {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      grid-template-columns: 160px 90px 1fr;
      gap: 10px;
      align-items: center;
    }

    .mono {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      color: var(--muted);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .badge.success {
      background: rgba(106, 255, 215, 0.16);
      color: #7bf3cc;
      border: 1px solid rgba(106, 255, 215, 0.3);
    }

    .badge.warn {
      background: rgba(245, 165, 36, 0.14);
      color: #f5c36a;
      border: 1px solid rgba(245, 165, 36, 0.3);
    }

    .badge.danger {
      background: rgba(255, 107, 107, 0.18);
      color: #ff9f9f;
      border: 1px solid rgba(255, 107, 107, 0.3);
    }

    .badge.muted {
      background: rgba(255, 255, 255, 0.08);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .footer {
      margin-top: auto;
      padding-bottom: 20px;
      color: var(--muted);
      font-size: 12px;
    }

    .artifact-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .btn-small {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      cursor: pointer;
      font-size: 12px;
    }

    .metrics {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .stage-help {
      /* removed absolute positioning */
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      font-weight: 700;
      font-family: "Space Grotesk", sans-serif;
      cursor: help;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
      font-size: 10px;
      margin-left: 8px;
      /* Spacing from title */
      opacity: 0.4;
      position: relative;
      /* For tooltip positioning context */
    }

    .stage-help:hover,
    .stage-help:focus {
      outline: none;
      background: var(--panel-2);
      border-color: rgba(255, 255, 255, 0.22);
      transform: translateY(-1px);
      opacity: 1;
    }

    .stage-help-tooltip {
      display: none;
      position: absolute;
      right: 0;
      bottom: 100%;
      margin-bottom: 8px;
      width: max-content;
      max-width: 400px;
      background: var(--panel-2);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 12px;
      text-align: left;
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
      white-space: normal;
      line-height: 1.5;
      z-index: 100;
    }

    .stage-help:hover .stage-help-tooltip,
    .stage-help:focus .stage-help-tooltip {
      display: block;
    }

    /* Fix for left-most tooltips getting cut off */
    .stage-card:nth-child(3n+1) .stage-help-tooltip {
      left: 0;
      right: auto;
    }

    pre {
      background: #0d1219;
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 12px;
      overflow: auto;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      /* removed max-height to let flex container handle scrolling */
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 0 0;
      gap: 0;
      transition: grid-template-columns 0.2s ease;
      flex: 1;
      min-height: 0;
      margin-bottom: 16px;
    }

    #split-handle {
      width: 0;
      cursor: col-resize;
      background: rgba(255, 255, 255, 0.06);
    }

    #pane-col {
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
      max-height: 100%;
    }

    #artifact-preview {
      flex: 1;
      overflow: auto;
      margin: 0;
      border-radius: 0 0 14px 14px;
      border-top: none;
      height: 100%;
    }

    .pane-header {
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      margin-bottom: 10px;
    }

    .pane-actions {
      display: flex;
      gap: 6px;
    }

    pre code.hljs {
      display: block;
    }

    @media (max-width: 1100px) {
      .layout {
        grid-template-columns: 1fr 0 0;
      }

      #pane-col {
        position: sticky;
        top: 10px;
      }
    }

    @media (max-width: 900px) {
      .controls {
        grid-template-columns: 1fr;
      }

      .timeline li {
        grid-template-columns: 120px 70px 1fr;
      }
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1 id="title-h1" title="Click to return to latest run">Pipeline Visibility</h1>
      <div class="pill">Live view of <strong>pipeline_state.json</strong> + events</div>
      <div class="pill" style="font-size:10px; opacity:0.5;">v12-debug</div>
    </div>
    <div class="pill mono" id="last-refresh">—</div>
  </header>

  <section class="controls">
    <div>
      <label for="run-select">Run</label>
      <div class="run-row">
        <div class="run-select" id="run-select">
          <button type="button" id="run-select-btn">
            <span class="label" id="run-select-label">Select a run…</span>
            <span class="chev">▾</span>
          </button>
          <div class="run-popover" id="run-popover">
            <input class="run-filter" id="run-filter" placeholder="Filter runs…" />
            <div class="run-options" id="run-options"></div>
          </div>
        </div>
        <label class="control-toggle" for="show-external" title="Include runs outside output/runs (e.g. /tmp)">
          <input type="checkbox" id="show-external" />
          External
        </label>
      </div>
    </div>
    <div>
      <label for="manual-run">Manual Run ID</label>
      <input id="manual-run" placeholder="e.g., deathtrap-text-ingest" />
    </div>
    <div>
      <label for="refresh-ms">Refresh (ms)</label>
      <input type="number" id="refresh-ms" value="4000" min="1000" step="500" />
    </div>
    <div style="display:flex; gap:8px;">
      <button id="load-btn">Load</button>
      <button class="secondary" id="toggle-auto">Pause Auto</button>
    </div>
  </section>

  <div class="layout" id="layout">
    <div id="main-col">
      <section class="grid" id="summary-grid"></section>
      <section class="card" id="cost-breakdown"></section>
      <section class="grid" id="stage-grid"></section>
      <section class="card timeline">
        <h3>Recent Events</h3>
        <ul id="timeline-list"></ul>
      </section>
    </div>
    <div id="split-handle" title="Drag to resize"></div>
    <aside class="card" id="pane-col" style="display:none;">
      <div class="pane-header">
        <h3>Artifact Pane</h3>
        <div class="pane-actions">
          <button class="btn-small" id="pane-open-tab">Open in new tab</button>
          <button class="btn-small" id="pane-close">Close</button>
        </div>
      </div>
      <div class="meta" id="artifact-meta"></div>
      <pre id="artifact-preview"></pre>
    </aside>
  </div>

  <div class="footer">
    Serve this file from the repo root (e.g., <code>python -m http.server 8000</code>) then open
    <code>/docs/pipeline-visibility.html</code>.
    The viewer polls <code>pipeline_state.json</code> and <code>pipeline_events.jsonl</code> inside
    <code>output/runs/&lt;run_id&gt;/</code>.
  </div>

  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/json.min.js"></script>
  <script>
    const ROOT = window.location.pathname.includes("/docs/") ? ".." : ".";
    const runSelect = document.getElementById("run-select");
    const runSelectBtn = document.getElementById("run-select-btn");
    const runSelectLabel = document.getElementById("run-select-label");
    const runPopover = document.getElementById("run-popover");
    const runFilter = document.getElementById("run-filter");
    const runOptions = document.getElementById("run-options");
    const manualRun = document.getElementById("manual-run");
    const loadBtn = document.getElementById("load-btn");
    const toggleAuto = document.getElementById("toggle-auto");
    const refreshInput = document.getElementById("refresh-ms");
    const showExternal = document.getElementById("show-external");
    const lastRefresh = document.getElementById("last-refresh");
    const summaryGrid = document.getElementById("summary-grid");
    const costBreakdown = document.getElementById("cost-breakdown");
    const stageGrid = document.getElementById("stage-grid");
    const timelineList = document.getElementById("timeline-list");
    const layout = document.getElementById("layout");
    const mainCol = document.getElementById("main-col");
    const splitHandle = document.getElementById("split-handle");
    const artifactPanel = document.getElementById("pane-col");
    const artifactMeta = document.getElementById("artifact-meta");
    const artifactPreview = document.getElementById("artifact-preview");
    const paneClose = document.getElementById("pane-close");
    const paneOpenTab = document.getElementById("pane-open-tab");
    const titleH1 = document.getElementById("title-h1");

    let currentRun = null;
    let userSelectedRun = false;
    let autoTimer = null;
    let liveTimer = null;
    const artifactCache = {};
    const instCache = {};
    const runMeta = {};
    let costBreakdownOpen = false;

    const statusDescriptors = {
      "running": { text: "Running", class: "running" },
      "done": { text: "Done", class: "done" },
      "failed": { text: "Failed", class: "failed" },
      "crashed": { text: "Crashed", class: "failed" },
      "skipped": { text: "Skipped", class: "skipped" },
      "queued": { text: "Queued", class: "muted" }
    };

    const RUN_PARAM = "run";
    function getRunFromUrl() {
      try {
        const params = new URLSearchParams(window.location.search);
        const runId = params.get(RUN_PARAM);
        return runId && runId.trim() ? runId.trim() : null;
      } catch {
        return null;
      }
    }

    function setRunInUrl(runId, replace = false) {
      try {
        const url = new URL(window.location.href);
        if (runId) url.searchParams.set(RUN_PARAM, runId);
        else url.searchParams.delete(RUN_PARAM);
        if (replace) window.history.replaceState(null, "", url.toString());
        else window.history.pushState(null, "", url.toString());
      } catch {
        // ignore URL update failures (file://, restrictive history, etc.)
      }
    }

    function artifactUrl(artifact, base) {
      if (!artifact) return null;
      if (/^https?:\/\//.test(artifact)) return artifact;          // absolute
      if (artifact.startsWith(ROOT + "/")) return artifact;        // already rooted
      if (artifact.startsWith("output/")) return `${ROOT}/${artifact}`; // repo-relative
      if (base) return `${base}/${artifact}`;                      // relative to run base
      return `${ROOT}/${artifact}`;
    }

    function escapeHtml(str) {
      return str.replace(/[&<>'"]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }[c]));
    }

    function renderPretty(text, lang = "json") {
      const code = document.createElement("code");
      code.className = `language-${lang}`;
      code.textContent = text; // safer than innerHTML
      artifactPreview.innerHTML = "";
      const pre = document.createElement("pre");
      pre.appendChild(code);
      artifactPreview.appendChild(pre);
      if (window.hljs) {
        // small delay to ensure DOM is ready if needed, though usually immediate is fine
        requestAnimationFrame(() => {
          try { hljs.highlightElement(code); } catch (e) { console.error(e); }
        });
      }
    }

    function openPane() {
      artifactPanel.style.display = "block";
      layout.style.gridTemplateColumns = "1fr 6px min(45vw, 640px)";
      splitHandle.style.width = "6px";
    }

    function closePane() {
      artifactPanel.style.display = "none";
      layout.style.gridTemplateColumns = "1fr 0 0";
      splitHandle.style.width = "0";
    }

    paneClose.onclick = () => closePane();
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closePane();
    });
    paneOpenTab.onclick = () => {
      const path = paneOpenTab.dataset.path;
      const stage = paneOpenTab.dataset.stage;
      if (path) openArtifactTab(stage || "", path);
    };

    let dragging = false;
    splitHandle.addEventListener("mousedown", () => { dragging = true; });
    window.addEventListener("mouseup", () => { dragging = false; });
    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const total = layout.getBoundingClientRect();
      const mainWidth = e.clientX - total.left;
      const paneWidth = Math.max(280, total.width - mainWidth - 6);
      layout.style.gridTemplateColumns = `${Math.max(320, mainWidth)}px 6px ${paneWidth}px`;
    });

    function parseJSONL(text) {
      return text.split("\n").filter(Boolean).map(line => {
        try { return JSON.parse(line); } catch { return null; }
      }).filter(Boolean);
    }

    async function fetchJSON(path) {
      const res = await fetch(path + "?t=" + Date.now());
      if (!res.ok) throw new Error(`Fetch failed: ${path}`);
      return res.json();
    }
    async function fetchJSONL(path) {
      const res = await fetch(path + "?t=" + Date.now());
      if (!res.ok) throw new Error(`Fetch failed: ${path}`);
      const text = await res.text();
      return parseJSONL(text);
    }

    function parseTimestamp(val) {
      if (!val) return -Infinity;
      // Trim fractional seconds to 3 digits for JS Date.parse compatibility
      const fixed = val.replace(/\\.(\\d{3})\\d+Z$/, ".$1Z");
      const ts = Date.parse(fixed);
      return isNaN(ts) ? -Infinity : ts;
    }

    function isValidTs(ts) {
      return Number.isFinite(ts) && ts > 0;
    }

    function summariseRunState(state) {
      const topStatus = (state?.status || "").toLowerCase();
      if (topStatus) {
        const percentsTop = Object.values(state?.stages || {}).map(s => (
          s?.progress?.percent != null ? s.progress.percent : (s?.status === "done" ? 100 : 0)
        ));
        const avgTop = percentsTop.length ? Math.round(percentsTop.reduce((a, b) => a + b, 0) / percentsTop.length) : null;
        return { status: topStatus, percent: avgTop };
      }
      const stages = state?.stages || {};
      const entries = Object.entries(stages);
      if (!entries.length) {
        const status = (state?.status || "unknown").toLowerCase();
        return { status, percent: null };
      }
      const failed = entries.some(([, s]) => s?.status === "failed");
      const running = entries.some(([, s]) => s?.status === "running");
      const allDone = entries.every(([, s]) => ["done", "failed", "skipped"].includes(s?.status));
      let status = "queued";
      if (failed) status = "failed";
      else if (allDone) status = "done";
      else if (running) status = "running";

      const percents = entries.map(([, s]) => (s?.progress?.percent != null ? s.progress.percent : (s?.status === "done" ? 100 : 0)));
      const avg = percents.length ? Math.round(percents.reduce((a, b) => a + b, 0) / percents.length) : null;
      return { status, percent: avg };
    }

    function formatRunLabel(entry) {
      const row = entry.row || {};
      return row.run_id || "Select a run…";
    }

    function renderRunOptions(list) {
      if (!runOptions) return;
      runOptions.innerHTML = "";
      if (!list.length) {
        const empty = document.createElement("div");
        empty.className = "mono";
        empty.textContent = "No runs found.";
        runOptions.appendChild(empty);
        return;
      }
      list.forEach(entry => {
        const row = entry.row || {};
        const opt = document.createElement("div");
        opt.className = `run-option${row.run_id === currentRun ? " active" : ""}`;
        opt.dataset.runId = row.run_id;
        const status = entry.status || "unknown";
        const percent = entry.percent != null ? `${entry.percent}%` : "—";
        const ts = isValidTs(entry.ts) ? new Date(entry.ts).toLocaleString() : "unknown";
        const input = row.input?.pdf || row.path || "unknown";
        opt.innerHTML = `
          <div class="run-title">
            <span class="status-pill ${status}">${status}</span>
            <span>${row.run_id}</span>
          </div>
          <div class="run-meta">
            <span>${percent}</span>
            <span>${ts}</span>
            <span>${input}</span>
          </div>
        `;
        opt.onclick = () => {
          currentRun = row.run_id;
          userSelectedRun = true;
          setRunInUrl(currentRun);
          runSelectLabel.textContent = formatRunLabel(entry);
          closeRunPopover();
          loadRun(currentRun);
        };
        runOptions.appendChild(opt);
      });
    }

    function openRunPopover() {
      if (!runPopover) return;
      runPopover.classList.add("open");
      if (runFilter) {
        runFilter.value = "";
        runFilter.focus();
        renderRunOptions(runEntries);
      }
    }

    function closeRunPopover() {
      if (!runPopover) return;
      runPopover.classList.remove("open");
    }

    function isInternalRunPath(row) {
      const path = row?.path || "";
      if (!path) return true; // default to output/runs/<run_id>
      if (path.startsWith("output/runs/")) return true;
      return path.includes("/output/runs/");
    }

    async function loadManifest() {
      const manifestPath = `${ROOT}/output/run_manifest.jsonl`;
      try {
        const res = await fetch(manifestPath);
        if (!res.ok) throw new Error();
        const lines = parseJSONL(await res.text());

        const candidates = lines.slice(-150); // last N entries

        async function resolveEntry(row) {
          if (!row?.run_id) return { row, ts: 0, exists: false };
          const base = row.path ? `${ROOT}/${row.path}` : `${ROOT}/output/runs/${row.run_id}`;
          let state = null;
          let exists = false;
          try {
            state = await fetchJSON(`${base}/pipeline_state.json`);
            exists = true;
          } catch {
            exists = false;
          }

          // Try to parse timestamp from run_id (e.g. ...20251124e)
          let ts = 0;
          const dateMatch = row.run_id.match(/(\d{8})([a-z]?)$/);
          if (dateMatch) {
            const dStr = dateMatch[1];
            const suffix = dateMatch[2] || "";
            // approximate time: date + suffix offset
            const y = dStr.slice(0, 4), m = dStr.slice(4, 6), d = dStr.slice(6, 8);
            ts = new Date(`${y}-${m}-${d}T00:00:00Z`).getTime();
            if (suffix) ts += (suffix.charCodeAt(0) - 96) * 1000; // a=1s, b=2s...
          }

          const direct = parseTimestamp(row.created_at || row.updated_at || "");
          if (isValidTs(direct)) ts = direct;
          if (state) {
            let stateTs = parseTimestamp(state.updated_at || state.created_at || state.timestamp || "");
            if (!stateTs && state.stages) {
              const stageTimes = Object.values(state.stages).map(s => parseTimestamp(s.updated_at));
              const maxStage = Math.max(0, ...stageTimes.filter(Boolean));
              stateTs = maxStage;
            }
            if (isValidTs(stateTs)) ts = Math.max(ts || 0, stateTs);
          }
          const summary = state ? summariseRunState(state) : { status: "unknown", percent: null };
          return { row, ts, exists, status: summary.status, percent: summary.percent };
        }

        const resolved = await Promise.all(candidates.map(resolveEntry));
        const includeExternal = !!showExternal?.checked;
        const filtered = resolved.filter(r => r.exists && (includeExternal || isInternalRunPath(r.row)));
        const byPath = new Map();
        filtered.forEach(entry => {
          const row = entry.row || {};
          const key = row.path || `output/runs/${row.run_id}`;
          const prev = byPath.get(key);
          if (!prev || (entry.ts || 0) > (prev.ts || 0)) {
            byPath.set(key, entry);
          }
        });
        const unique = Array.from(byPath.values());
        const sorted = unique
          .sort((a, b) => (b.ts || 0) - (a.ts || 0))
          .map(x => x);

        runEntries = sorted;
        renderRunOptions(runEntries);
        sorted.forEach(entry => {
          const row = entry.row;
          runMeta[row.run_id] = row;
        });
        const currentExists = sorted.some(r => r.row?.run_id === currentRun);
        if (!userSelectedRun) {
          currentRun = sorted.length ? sorted[0].row.run_id : null; // newest
        } else if (!currentExists && currentRun) {
          // Keep user-selected run (URL/manual), but still attempt to load it.
        }
        if (currentRun && runSelectLabel) {
          const entry = sorted.find(r => r.row?.run_id === currentRun);
          if (entry) runSelectLabel.textContent = formatRunLabel(entry);
        }
        lastRefresh.textContent = `Manifest: ${manifestPath} (${sorted.length}/${filtered.length} shown)`;
      } catch {
        runEntries = [];
        renderRunOptions(runEntries);
        if (runSelectLabel) runSelectLabel.textContent = "No manifest found (add run manually)";
      }
    }

    function formatCurrency(value, currency) {
      const num = Number(value);
      if (!isFinite(num)) return "—";
      const code = currency || "USD";
      try {
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: code,
          minimumFractionDigits: 4,
          maximumFractionDigits: 4
        }).format(num);
      } catch {
        return `${num.toFixed(4)} ${code}`;
      }
    }

    function percentText(p) {
      if (p === null || p === undefined) return "—";
      return `${p}%`;
    }

    function formatDuration(seconds) {
      if (seconds == null || isNaN(seconds) || seconds < 0) return "—";
      if (seconds < 1) return "<1s";
      const s = Math.floor(seconds % 60);
      const m = Math.floor((seconds / 60) % 60);
      const h = Math.floor(seconds / 3600);
      if (h) return `${h}h ${m.toString().padStart(2, "0")}m`;
      return `${m}:${s.toString().padStart(2, "0")}s`;
    }

    function computeStageDurations(events, stages) {
      const map = {};
      const byStage = {};

      // Group events by stage
      const MIN_VALID_TS = new Date("2025-01-01").getTime();
      events.forEach(evt => {
        if (!evt.stage) return;
        const ts = parseTimestamp(evt.timestamp);
        if (!ts || ts < MIN_VALID_TS) return;

        if (!byStage[evt.stage]) byStage[evt.stage] = [];
        byStage[evt.stage].push(evt);
      });

      Object.keys(byStage).forEach(stage => {
        const stageEvents = byStage[stage];
        // Sort by timestamp string
        stageEvents.sort((a, b) => (a.timestamp || "").localeCompare(b.timestamp || ""));

        let totalDuration = 0;
        let runCount = 0;
        let sessionStart = null;
        let lastTs = 0;
        const GAP_THRESHOLD = 15 * 60 * 1000; // 15 mins

        stageEvents.forEach((evt, idx) => {
          const ts = parseTimestamp(evt.timestamp);
          if (!ts) return;

          let isNewSession = false;
          if (lastTs && (ts - lastTs > GAP_THRESHOLD)) {
            isNewSession = true;
          }

          if (isNewSession) {
            // End previous session
            if (sessionStart !== null) {
              totalDuration += (lastTs - sessionStart);
              runCount++;
              sessionStart = null;
            }
          }

          // Start new session if needed
          if (sessionStart === null) {
            sessionStart = ts;
          }

          // If this is the last event, close the session
          if (idx === stageEvents.length - 1) {
            if (sessionStart !== null) {
              totalDuration += (ts - sessionStart);
              runCount++;
            }
          }

          lastTs = ts;
        });

        // If totalDuration is 0 but we have events, maybe it was instantaneous?
        // Or maybe we just have one event?
        // If we have >0 events, runCount should be at least 1.
        if (runCount === 0 && stageEvents.length > 0) runCount = 1;

        map[stage] = {
          totalDuration,
          runCount,
          lastStatus: stageEvents[stageEvents.length - 1].status,
          // Keep start/end for compatibility if needed, but UI should use totalDuration
          start: stageEvents[0] ? parseTimestamp(stageEvents[0].timestamp) : null,
          end: stageEvents[stageEvents.length - 1] ? parseTimestamp(stageEvents[stageEvents.length - 1].timestamp) : null
        };

        if (stage === "build") {
          console.log("Build map entry:", map[stage]);
        }
      });

      // fallbacks from state updated_at when no events
      Object.entries(stages || {}).forEach(([stage, info]) => {
        if (map[stage]) return;
        const ts = parseTimestamp(info.updated_at);
        if (ts) map[stage] = { totalDuration: 0, runCount: 1, lastStatus: info.status, start: ts, end: ts };
      });
      return map;
    }

    function summariseStages(stages, totalOverride = null) {
      const entries = Object.entries(stages || {});
      const done = entries.filter(([, s]) => s.status === "done").length;
      const failed = entries.filter(([, s]) => s.status === "failed").length;
      const running = entries.filter(([, s]) => s.status === "running").length;
      const percents = entries.map(([, s]) => {
        if (s.progress && s.progress.percent != null) return s.progress.percent;
        if (["done", "failed", "skipped"].includes(s.status)) return 100;
        return 0;
      });
      const total = totalOverride && totalOverride > entries.length ? totalOverride : entries.length;
      const sum = percents.reduce((a, b) => a + b, 0);
      const avg = total ? Math.round(sum / total) : 0;
      return { done, failed, running, avg, total };
    }

    function getRunningStageName(stages) {
      const entries = Object.entries(stages || {}).filter(([, s]) => s.status === "running");
      if (!entries.length) return null;
      entries.sort((a, b) => parseTimestamp(b[1]?.updated_at) - parseTimestamp(a[1]?.updated_at));
      return entries[0][0];
    }

    function badge(status) {
      const span = document.createElement("span");
      const desc = statusDescriptors[status] || { text: status || "unknown", class: "muted" };
      span.className = `badge ${desc.class}`;
      span.textContent = desc.text.toUpperCase();
      return span;
    }

    async function loadRun(runId) {
      if (!runId) return;
      currentRun = runId;
      const meta = runMeta[runId] || {};
      const base = meta.path ? `${ROOT}/${meta.path}` : `${ROOT}/output/runs/${runId}`;
      try {
        const instPath = meta.instrumentation?.json
          ? `${ROOT}/${meta.instrumentation.json}`
          : `${base}/instrumentation.json`;
        const [state, events, instrumentation, plan] = await Promise.all([
          fetchJSON(`${base}/pipeline_state.json`),
          fetchJSONL(`${base}/pipeline_events.jsonl`).catch(() => []),
          fetchJSON(instPath).catch(() => null),
          fetchJSON(`${base}/snapshots/plan.json`).catch(() => null)
        ]);
        if (instrumentation) instCache[runId] = instrumentation;
        render(state, events, base, instCache[runId], plan);
        lastRefresh.textContent = `Updated ${new Date().toLocaleTimeString()}`;
      } catch (e) {
        stageGrid.innerHTML = "";
        summaryGrid.innerHTML = "";
        timelineList.innerHTML = `<li class="mono">Unable to load run "${runId}". Check that output/runs/${runId}/pipeline_state.json exists.</li>`;
      }
    }

    async function loadValidationReport(base, state) {
      const validationJsonPath = `${base}/validation_report.json`;
      const validationHtmlPath = `${base}/validation_report.html`;

      try {
        // Check if HTML report exists
        const htmlRes = await fetch(validationHtmlPath + "?t=" + Date.now());
        if (htmlRes.ok) {
          const linkBtn = document.getElementById("validation-report-link");
          if (linkBtn) linkBtn.style.display = "inline-block";
        }
      } catch {
        // HTML report doesn't exist, that's okay
      }

      try {
        // Try to load JSON report
        const jsonRes = await fetch(validationJsonPath + "?t=" + Date.now());
        if (!jsonRes.ok) return;

        const validationData = await jsonRes.json();

        // Only show validation summary if run is complete
        const runStatus = (state.status || "").toLowerCase();
        const isComplete = runStatus === "done" || runStatus === "failed" || runStatus === "crashed";
        if (!isComplete && state.stages) {
          const stages = Object.values(state.stages);
          const allDone = stages.length > 0 && stages.every(s =>
            s.status === "done" || s.status === "failed" || s.status === "skipped"
          );
          if (!allDone) return; // Run not complete yet
        }

        // Create validation summary card
        const validationCard = document.createElement("div");
        validationCard.className = "card";
        validationCard.innerHTML = "<h3>Validation Summary</h3>";

        const isValid = validationData.is_valid;
        const statusClass = isValid ? "status-pill big done" : "status-pill big failed";
        const statusText = isValid ? "VALID" : "INVALID";

        const stats = document.createElement("div");
        stats.className = "meta";
        stats.style.marginTop = "10px";

        const missingCount = (validationData.missing_sections || []).length;
        const noTextCount = (validationData.sections_with_no_text || []).length;
        const noChoicesCount = (validationData.sections_with_no_choices || []).length;
        const brokenLinksCount = Object.keys(validationData.forensics?.broken_links || {}).length;
        const orphansCount = Object.keys(validationData.forensics?.orphans || {}).length;

        stats.innerHTML = `
          <span class="${statusClass}">${statusText}</span>
          <span>Total Sections: <strong>${validationData.total_sections || 0}</strong></span>
          <span>Missing: <strong>${missingCount}</strong></span>
          <span>No Text: <strong>${noTextCount}</strong></span>
          <span>No Choices: <strong>${noChoicesCount}</strong></span>
          <span>Broken Links: <strong>${brokenLinksCount}</strong></span>
          <span>Orphans: <strong>${orphansCount}</strong></span>
        `;

        validationCard.appendChild(stats);

        // Add link to full report if HTML exists
        const linkBtn = document.getElementById("validation-report-link");
        if (linkBtn && linkBtn.style.display !== "none") {
          const reportLink = document.createElement("div");
          reportLink.style.marginTop = "10px";
          reportLink.innerHTML = `<button class="btn-small" onclick="window.open('${validationHtmlPath}', '_blank')">View Full Forensic Report</button>`;
          validationCard.appendChild(reportLink);
        }

        // Insert validation card before the debug card
        const debugCard = document.querySelector("#debug-details")?.closest(".card");
        if (debugCard) {
          debugCard.parentNode.insertBefore(validationCard, debugCard);
        } else {
          summaryGrid.appendChild(validationCard);
        }

      } catch (e) {
        console.log("No validation report found or error loading:", e);
      }
    }

    function render(state, events, base, instrumentation, plan) {
      const stages = state.stages || {};
      const plannedTotal = plan && plan.nodes ? Object.keys(plan.nodes).length : null;
      const stats = summariseStages(stages, plannedTotal);
      const runningStage = getRunningStageName(stages);
      const meta = runMeta[state.run_id || currentRun] || {};
      const currency = instrumentation?.pricing?.currency || "USD";
      // Resolve input artifact (pdf, images_dir, etc.)
      const inputMeta = meta.input || {};
      let inputPath = null;
      let inputLabel = "Input";
      const toAbs = (p) => {
        if (!p) return null;
        if (/^https?:\/\//.test(p)) return p;
        if (p.startsWith(ROOT + "/")) return p;
        return `${ROOT}/${p}`;
      };
      if (inputMeta.pdf) {
        inputPath = toAbs(inputMeta.pdf);
        inputLabel = "Input PDF";
      } else if (inputMeta.images_dir) {
        inputPath = toAbs(inputMeta.images_dir);
        inputLabel = "Input images";
      } else if (inputMeta.images) {
        const p = Array.isArray(inputMeta.images) ? inputMeta.images[0] : inputMeta.images;
        inputPath = toAbs(p);
        inputLabel = "Input images";
      } else if (inputMeta.text_glob) {
        inputPath = toAbs(inputMeta.text_glob);
        inputLabel = "Input text";
      }
      const finalArtifact = findFinalArtifact(stages);

      summaryGrid.innerHTML = "";
      const runSummary = summariseRunState(state);
      const runningStageDisplay = runningStage
        ? `<strong>Currently Running:</strong> ${runningStage}`
        : "No stage currently running";
      summaryGrid.appendChild(makeStatCard("Overall Progress", `${stats.avg}%`, [
        `<span class="status-pill big ${runSummary.status || "unknown"}">${(runSummary.status || "unknown").toUpperCase()}</span>`,
        runningStageDisplay,
        `${stats.done}/${stats.total} done`,
        `${stats.running} running`,
        `${stats.failed} failed`,
        getRunDurationHtml(state, events)
      ]));
      const costCard = makeStatCard("Total Cost", instrumentation ? formatCurrency(instrumentation.totals?.cost, currency) : "N/A", [
        instrumentation ? `Currency: ${currency}` : "Instrumentation not found",
        instrumentation ? `Calls: ${instrumentation.totals?.calls || 0}` : "",
        instrumentation ? `Tokens: ${instrumentation.totals?.prompt_tokens || 0} / ${instrumentation.totals?.completion_tokens || 0}` : "",
        `<button class="btn-small" id="toggle-cost-breakdown">${costBreakdownOpen ? "Hide" : "Show"} Cost Breakdown</button>`
      ].filter(Boolean));
      summaryGrid.appendChild(costCard);
      const toggleBtn = costCard.querySelector("#toggle-cost-breakdown");
      if (toggleBtn) {
        toggleBtn.onclick = () => {
          costBreakdownOpen = !costBreakdownOpen;
          if (costBreakdown) costBreakdown.style.display = costBreakdownOpen ? "block" : "none";
          toggleBtn.textContent = `${costBreakdownOpen ? "Hide" : "Show"} Cost Breakdown`;
        };
      }
      summaryGrid.appendChild(makeStatCard("Run", state.run_id || currentRun || "n/a", [
        state.updated_at ? `updated ${state.updated_at}` : "live",
        base.replace(`${ROOT}/`, "")
      ]));
      // Check for validation_report.html
      const validationReportHtml = `${base}/validation_report.html`;
      summaryGrid.appendChild(makeStatCard("Artifacts", "", [
        inputPath
          ? `<button class="btn-small" onclick="window.open('${inputPath}', '_blank')">${inputLabel}</button>`
          : "Input artifact unknown",
        finalArtifact
          ? `<button class="btn-small" onclick="openArtifactTab('final', '${ROOT}/${finalArtifact}')">Final JSON</button>`
          : "Final artifact not detected",
        `<button class="btn-small" id="validation-report-link" onclick="window.open('${validationReportHtml}', '_blank')" style="display:none;">Validation Report</button>`,
        "Click any stage to open artifacts"
      ]));

      // Debug Card
      const debugCard = document.createElement("div");
      debugCard.className = "card";
      debugCard.innerHTML = `<h3>Debug Info</h3><button class="btn-small" onclick="const el=document.getElementById('debug-details'); el.style.display=el.style.display==='none'?'block':'none'">Toggle Details</button><div id="debug-details" style="display:none; margin-top:10px; font-family:monospace; font-size:10px; white-space:pre-wrap;"></div>`;
      summaryGrid.appendChild(debugCard);
      const inst = document.createElement("div");
      inst.className = "card";
      inst.innerHTML = `<h3>Instrumentation</h3>`;
      const links = document.createElement("div");
      links.className = "meta";
      if (meta.instrumentation?.json) {
        const btn = document.createElement("button");
        btn.className = "btn-small";
        btn.onclick = () => window.open(`${ROOT}/${meta.instrumentation.json}`, '_blank');
        btn.textContent = "JSON report";
        links.appendChild(btn);
      }
      if (meta.instrumentation?.md) {
        const btn = document.createElement("button");
        btn.className = "btn-small";
        btn.onclick = () => openArtifactTab("Instrumentation", `${ROOT}/${meta.instrumentation.md}`);
        btn.textContent = "Markdown summary";
        links.appendChild(btn);
      }
      if (instrumentation) {
        const totals = instrumentation.totals || {};
        const perModel = totals.per_model || {};
        const models = Object.entries(perModel).sort((a, b) => (b[1].cost || 0) - (a[1].cost || 0)).slice(0, 3);
        const stats = document.createElement("div");
        stats.className = "meta";
        stats.innerHTML = `
          <span>Total cost: ${formatCurrency(totals.cost, currency)}</span>
          <span>Calls: ${totals.calls || 0}</span>
          <span>Tokens: ${totals.prompt_tokens || 0} / ${totals.completion_tokens || 0}</span>
        `;
        inst.appendChild(stats);
        if (models.length) {
          const top = document.createElement("div");
          top.className = "meta";
          top.innerHTML = `<span>Top models:</span>${models.map(([m, v]) => `<span>${m}: ${formatCurrency(v.cost, currency)}</span>`).join("")}`;
          inst.appendChild(top);
        }
      } else {
        const msg = document.createElement("div");
        msg.className = "meta";
        msg.innerHTML = "<span>Instrumentation data not found for this run.</span>";
        inst.appendChild(msg);
      }
      if (links.children.length) inst.appendChild(links);
      summaryGrid.appendChild(inst);

      // Load and display validation report if available
      loadValidationReport(base, state);

      const durations = computeStageDurations(events, stages);
      if (costBreakdown) costBreakdown.style.display = costBreakdownOpen ? "block" : "none";
      renderCostBreakdown(stages, instrumentation, currency);
      renderStages(stages, events, base, instrumentation, durations, currency);
      renderTimeline(events);
    }

    function makeStatCard(title, value, lines) {
      const card = document.createElement("div");
      card.className = "card";
      card.innerHTML = `<h3>${title}</h3><div class="status done" style="font-size:24px;">${value}</div>`;
      if (lines?.length) {
        const ul = document.createElement("div");
        ul.className = "meta";
        lines.forEach(l => {
          const span = document.createElement("span");
          const content = (typeof l === "string") ? l : (l?.html ?? l);
          if (typeof content === "string" && content.includes("<")) {
            span.innerHTML = content;
            span.querySelectorAll("a").forEach(a => {
              if (!a.target) a.target = "_blank";
              a.rel = "noreferrer noopener";
            });
          } else {
            span.textContent = content ?? "";
          }
          ul.appendChild(span);
        });
        card.appendChild(ul);
      }
      return card;
    }

    function renderCostBreakdown(stages, instrumentation, currency) {
      if (!costBreakdown) return;
      costBreakdown.innerHTML = "";
      const title = document.createElement("h3");
      title.textContent = "Cost Breakdown";
      costBreakdown.appendChild(title);

      if (!instrumentation?.stages || !instrumentation.stages.length) {
        const msg = document.createElement("div");
        msg.className = "meta";
        msg.textContent = "No instrumentation cost data for this run.";
        costBreakdown.appendChild(msg);
        return;
      }

      const totalCost = Number(instrumentation.totals?.cost);
      const rows = instrumentation.stages
        .filter(s => s?.id)
        .map(s => ({
          id: s.id,
          moduleId: stages?.[s.id]?.module_id || "",
          cost: Number(s.llm_totals?.cost || 0)
        }))
        .sort((a, b) => b.cost - a.cost);

      const table = document.createElement("table");
      table.className = "cost-table";
      table.innerHTML = `
        <thead>
          <tr>
            <th>Stage</th>
            <th>Cost</th>
            <th>% of total</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = table.querySelector("tbody");
      rows.forEach(row => {
        const tr = document.createElement("tr");
        const stageCell = document.createElement("td");
        stageCell.innerHTML = `<div class="cost-name">${row.id}</div>${row.moduleId ? `<div class="cost-sub">${row.moduleId}</div>` : ""}`;

        const costCell = document.createElement("td");
        costCell.className = "cost-value";
        costCell.textContent = formatCurrency(row.cost, currency);

        const pctCell = document.createElement("td");
        if (isFinite(totalCost) && totalCost > 0) {
          pctCell.textContent = `${((row.cost / totalCost) * 100).toFixed(1)}%`;
        } else {
          pctCell.textContent = "—";
        }

        tr.appendChild(stageCell);
        tr.appendChild(costCell);
        tr.appendChild(pctCell);
        tbody.appendChild(tr);
      });
      costBreakdown.appendChild(table);
    }

    function renderStages(stages, events, base, instrumentation, durations, currency) {
      stageGrid.innerHTML = "";
      const instMap = {};
      if (instrumentation?.stages) {
        instrumentation.stages.forEach(s => { if (s.id) instMap[s.id] = s; });
      }
      const stageEntries = Object.entries(stages || {}).filter(([_, info]) => info?.module_id || info?.description);
      const stageFirstTs = {};
      if (events && events.length) {
        events.forEach(e => {
          const t = parseTimestamp(e.timestamp);
          if (t === -Infinity) return;
          const st = e.stage;
          if (stageFirstTs[st] === undefined || t < stageFirstTs[st]) {
            stageFirstTs[st] = t;
          }
        });
      }
      const ordered = stageEntries.map(([k]) => k).sort((a, b) => {
        const tsA = (durations?.[a]?.start ?? stageFirstTs[a] ?? parseTimestamp(stages[a]?.updated_at));
        const tsB = (durations?.[b]?.start ?? stageFirstTs[b] ?? parseTimestamp(stages[b]?.updated_at));
        if (tsA !== tsB) return tsA - tsB;
        return a.localeCompare(b);
      });
      console.log('Ordered stages:', ordered);

      const debugDetails = document.getElementById('debug-details');
      if (debugDetails) {
        debugDetails.textContent = ordered.map(s => {
          const d = durations[s];
          const durSec = d ? (d.totalDuration / 1000).toFixed(1) : "N/A";
          return `${s.padEnd(20)}: ${durSec}s (${d?.runCount || 0} runs)`;
        }).join('\n');
      }

      ordered.forEach(stage => {
        console.log(`Rendering stage: ${stage}`, stages[stage], durations[stage]);
        const dur = durations[stage];
        const info = stages[stage];
        const card = document.createElement("div");
        card.className = "card stage-card";
        const status = info.status || "queued";
        const prog = info.progress || {};

        const elapsed = dur ? formatDuration(dur.totalDuration / 1000) : "—";
        const runCountText = (dur && dur.runCount > 1) ? ` • ${dur.runCount} RUNS` : "";

        card.innerHTML = `
      <div class="stage-header">
        <span class="stage-name">${stage}</span>
        <span class="stage-time" style="margin-left:auto;">⏱ ${elapsed}</span>
      </div>
      <div class="status ${statusDescriptors[status]?.class || ""}">${status.toUpperCase()}${runCountText}</div>
      <div class="progress-bar"><span style="width:${Math.min(100, prog.percent || (status === "done" ? 100 : 0))}%"></span></div>
      <div class="meta">
        <span>${prog.current ?? ""}${prog.total != null ? " / " + prog.total : ""}</span>
        <span>${percentText(prog.percent)}</span>
        <span>${(info.updated_at || "").replace(/\\.(\\d{3})\\d+Z$/, ".$1Z")}</span>
      </div>
    `;

        const chips = document.createElement("div");
        chips.className = "chips";
        if (info.artifact) {
          const name = info.artifact.split("/").slice(-1)[0];
          const artChip = document.createElement("div");
          artChip.className = "chip";
          artChip.innerHTML = `<strong>Artifact</strong> ${name}`;
          chips.appendChild(artChip);
        }
        if (info.module_id) {
          const mod = document.createElement("div");
          mod.className = "chip";
          mod.innerHTML = `<strong>Module</strong> ${info.module_id}`;
          chips.appendChild(mod);
        }
        if (info.schema_version) {
          const sch = document.createElement("div");
          sch.className = "chip";
          sch.innerHTML = `<strong>Schema</strong> ${info.schema_version}`;
          chips.appendChild(sch);
        }
        const inst = instMap[stage];
        const description = info.description || inst?.description || (info.module_id
          ? `Stage ${stage} runs module ${info.module_id} (description not recorded yet).`
          : "Description not recorded for this stage yet.");
        const costVal = inst?.llm_totals?.cost || 0;
        const costChip = document.createElement("div");
        costChip.className = "chip";
        costChip.title = costVal === 0 ? "No LLM calls recorded for this stage (non-LLM step or module emitted no usage)" : "";
        costChip.innerHTML = `<strong>Cost</strong> ${instrumentation ? formatCurrency(costVal, currency) : "N/A"}`;
        chips.appendChild(costChip);
        if (inst && inst.wall_seconds != null) {
          const timeChip = document.createElement("div");
          timeChip.className = "chip";
          timeChip.innerHTML = `<strong>Wall</strong> ${inst.wall_seconds.toFixed(2)}s`;
          chips.appendChild(timeChip);
        }
        card.appendChild(chips);

        const actions = document.createElement("div");
        actions.className = "artifact-actions";
        if (info.artifact) {
          const open = document.createElement("button");
          open.className = "btn-small";
          open.textContent = "Open artifact (new tab)";
          open.onclick = () => openArtifactTab(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(open);

          const viewBtn = document.createElement("button");
          viewBtn.className = "btn-small";
          viewBtn.textContent = "View in pane";
          viewBtn.onclick = () => viewArtifact(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(viewBtn);

          const metricsBtn = document.createElement("button");
          metricsBtn.className = "btn-small";
          metricsBtn.textContent = "Load metrics";
          metricsBtn.onclick = () => loadMetrics(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(metricsBtn);
        }
        const history = events.filter(e => e.stage === stage);
        if (history.length) {
          const last = history[history.length - 1];
          const hint = document.createElement("div");
          hint.className = "metrics";
          // Trim milliseconds: "2025-11-26T15:45:01.123456Z" -> "2025-11-26T15:45:01Z"
          const cleanTs = (last.timestamp || "").replace(/\.\d+Z$/, "Z");
          hint.textContent = `${history.length} events | last: ${last.status} @ ${cleanTs}`;
          actions.appendChild(hint);
        }

        if (description) {
          const help = document.createElement("button");
          help.className = "stage-help";
          help.type = "button";
          help.setAttribute("aria-label", `What ${stage} does`);
          help.textContent = "?";
          const tip = document.createElement("div");
          tip.className = "stage-help-tooltip";
          tip.textContent = description;
          help.appendChild(tip);

          // Append to stage name container
          const header = card.querySelector(".stage-header");
          const nameEl = header ? header.querySelector(".stage-name") : null;
          if (nameEl) {
            // Insert after the stage name
            nameEl.after(help);
          }
        }
        card.appendChild(actions);
        stageGrid.appendChild(card);
      });
    }

    function renderTimeline(events) {
      timelineList.innerHTML = "";
      const recent = events.slice(-80).reverse();
      if (!recent.length) {
        timelineList.innerHTML = `<li class="mono">No events yet for this run.</li>`;
        return;
      }
      recent.forEach(evt => {
        const li = document.createElement("li");
        const badgeEl = badge(evt.status);
        const stage = document.createElement("div");
        stage.innerHTML = `<strong>${evt.stage}</strong><br><span class="mono">${evt.timestamp}</span>`;
        const prog = evt.percent != null ? `${evt.current || "?"}/${evt.total || "?"} (${evt.percent}%)` : "";
        const msg = document.createElement("div");
        msg.innerHTML = `<div class="mono">${prog}</div><div>${evt.message || ""}</div>`;
        const col1 = document.createElement("div");
        col1.appendChild(stage);
        const col2 = document.createElement("div");
        col2.appendChild(badgeEl);
        li.appendChild(stage);
        li.appendChild(col2);
        li.appendChild(msg);
        timelineList.appendChild(li);
      });
    }

    async function loadMetrics(stage, artifactPath) {
      openPane();
      artifactMeta.innerHTML = "";
      artifactPreview.textContent = "Loading…";
      paneOpenTab.dataset.path = artifactPath;
      paneOpenTab.dataset.stage = stage;

      if (artifactCache[artifactPath]) {
        renderMetrics(stage, artifactPath, artifactCache[artifactPath]);
        return;
      }

      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();
        let rows = [];
        const lowerPath = artifactPath.toLowerCase();
        if (lowerPath.endsWith(".jsonl")) {
          rows = parseJSONL(text);
        } else if (lowerPath.endsWith(".json")) {
          rows = Object.values(JSON.parse(text));
        }
        const confidences = rows.map(r => r.confidence).filter(v => v !== undefined && v !== null);
        const avg = confidences.length ? (confidences.reduce((a, b) => a + b, 0) / confidences.length).toFixed(3) : "n/a";
        const min = confidences.length ? Math.min(...confidences).toFixed(3) : "n/a";
        const max = confidences.length ? Math.max(...confidences).toFixed(3) : "n/a";
        const sample = rows.slice(0, 3);
        const metrics = { count: rows.length, avg, min, max, sample };
        artifactCache[artifactPath] = metrics;
        renderMetrics(stage, artifactPath, metrics);
      } catch (e) {
        artifactPreview.textContent = `Failed to load artifact: ${e.message}`;
      }
    }

    async function openArtifactTab(stage, artifactPath) {
      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();

        const pretty = formatMaybeJSON(text, artifactPath);
        const isMd = artifactPath.toLowerCase().endsWith(".md");
        const isJson = artifactPath.toLowerCase().endsWith(".json") || artifactPath.toLowerCase().endsWith(".jsonl");

        let highlightedCode = "";
        if (window.hljs) {
          if (isJson) {
            try {
              highlightedCode = hljs.highlight(pretty, { language: 'json' }).value;
            } catch (e) {
              console.warn("Highlight error", e);
              highlightedCode = escapeHtml(pretty);
            }
          } else if (isMd) {
            try {
              highlightedCode = hljs.highlight(pretty, { language: 'markdown' }).value;
            } catch (e) {
              highlightedCode = escapeHtml(pretty);
            }
          } else {
            highlightedCode = escapeHtml(pretty);
          }
        } else {
          highlightedCode = escapeHtml(pretty);
        }

        const win = window.open("", "_blank");
        if (!win) {
          alert("Please allow popups to view artifacts in a new tab.");
          return;
        }

        const html = `<!DOCTYPE html><html><head><title>${stage} artifact</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css"><style>body{margin:0;background:#0d1219;color:#e5e9f0;padding:20px;}pre{margin:0;white-space:pre-wrap;word-wrap:break-word;}</style></head><body><pre><code class="hljs">${highlightedCode}</code></pre></body></html>`;

        win.document.open();
        win.document.write(html);
        win.document.close();
      } catch (e) {
        alert(`Failed to open artifact: ${e.message}`);
      }
    }

    function formatMaybeJSON(text, artifactPath) {
      try {
        const lower = artifactPath.toLowerCase();
        if (lower.endsWith(".jsonl")) {
          const rows = parseJSONL(text);
          return JSON.stringify(rows, null, 2);
        }
        if (lower.endsWith(".json")) {
          return JSON.stringify(JSON.parse(text), null, 2);
        }
      } catch (e) {
        console.warn("Formatting failed, falling back to raw text", e);
        // fall through to raw text
      }
      return text;
    }

    function getStageInstrumentation(stage) {
      const inst = instCache[currentRun];
      if (!inst?.stages) return null;
      return inst.stages.find(s => s.id === stage);
    }

    async function viewArtifact(stage, artifactPath) {
      openPane();
      artifactPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      const inst = getStageInstrumentation(stage);
      const currency = instCache[currentRun]?.pricing?.currency || "USD";
      const chips = [
        `<div class="chip"><strong>Stage</strong> ${stage}</div>`,
        `<div class="chip"><strong>Path</strong> ${artifactPath}</div>`
      ];
      if (inst) {
        chips.push(`<div class="chip"><strong>Cost</strong> ${formatCurrency(inst.llm_totals?.cost, currency)}</div>`);
        chips.push(`<div class="chip"><strong>Calls</strong> ${inst.llm_totals?.calls || 0}</div>`);
        chips.push(`<div class="chip"><strong>Tokens</strong> ${inst.llm_totals?.prompt_tokens ||
          0}/${inst.llm_totals?.completion_tokens || 0}</div>`);
        if (inst.wall_seconds != null) {
          chips.push(`<div class="chip"><strong>Wall</strong> ${inst.wall_seconds.toFixed(2)}s</div>`);
        }
      } else {
        chips.push(`<div class="chip"><strong>Instrumentation</strong> not available</div>`);
      }
      artifactMeta.innerHTML = chips.join("");
      artifactPreview.textContent = "Loading artifact…";
      paneOpenTab.dataset.path = artifactPath;
      paneOpenTab.dataset.stage = stage;

      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();
        let parsed;
        const lower = artifactPath.toLowerCase();
        if (lower.endsWith(".jsonl")) {
          parsed = parseJSONL(text);
        } else if (lower.endsWith(".json")) {
          parsed = JSON.parse(text);
        } else {
          parsed = text;
        }

        const MAX_ROWS = 200;
        let displayVal = parsed;
        let clipped = false;
        if (Array.isArray(parsed) && parsed.length > MAX_ROWS) {
          displayVal = parsed.slice(0, MAX_ROWS);
          clipped = true;
        }
        const pretty = typeof displayVal === "string" ? displayVal : JSON.stringify(displayVal, null, 2);
        renderPretty(pretty, "json");
        if (clipped) {
          artifactPreview.innerHTML += `<div class="mono">… clipped to first ${MAX_ROWS} records …</div>`;
        }
      } catch (e) {
        artifactPanel.style.display = "block";
        artifactPreview.textContent = `Failed to load artifact: ${e.message}`;
      }
    }

    function renderMetrics(stage, artifactPath, metrics) {
      artifactMeta.innerHTML = `
<div class="chip"><strong>Stage</strong> ${stage}</div>
<div class="chip"><strong>Records</strong> ${metrics.count}</div>
<div class="chip"><strong>Confidence</strong> avg ${metrics.avg}, min ${metrics.min}, max ${metrics.max}</div>
<div class="chip"><strong>Path</strong> ${artifactPath}</div>
`;
      const sample = metrics.sample ?? [];
      const preview = {
        sample: sample,
        note: sample.length === metrics.count ? "full dataset preview" : `showing ${sample.length} of ${metrics.count} records`
      };
      renderPretty(JSON.stringify(preview, null, 2), "json");
    }

    function findFinalArtifact(stages) {
      if (!stages) return null;
      // Prefer explicit build_ff_engine (our FF final JSON)
      if (stages["build_ff_engine"]?.artifact) return stages["build_ff_engine"].artifact;

      const entries = Object.entries(stages);
      // Prefer confirm/dispatch outputs first
      const preferredOrder = ["confirm_plan", "dispatch", "dispatch_hint", "gap_analysis", "zoom_refine", "overview_plan"];
      for (const id of preferredOrder) {
        if (stages[id]?.artifact) return stages[id].artifact;
      }
      // Otherwise pick the most recent done stage with an artifact, but deprioritize validate-only stages
      const doneWithArtifact = entries
        .filter(([, v]) => v.artifact)
        .sort((a, b) => {
          const aIsValidate = a[0].startsWith("validate");
          const bIsValidate = b[0].startsWith("validate");
          if (aIsValidate !== bIsValidate) return aIsValidate ? 1 : -1; // prefer non-validate
          return parseTimestamp(b[1].updated_at) - parseTimestamp(a[1].updated_at);
        });
      return doneWithArtifact.length ? doneWithArtifact[0][1].artifact : null;
    }

    function startAuto() {
      stopAuto();
      const ms = Number(refreshInput.value) || 4000;
      autoTimer = setInterval(() => {
        if (currentRun) loadRun(currentRun);
      }, ms);
      toggleAuto.textContent = "Pause Auto";
    }
    function stopAuto() {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = null;
      toggleAuto.textContent = "Resume Auto";
    }

    loadBtn.onclick = () => {
      const chosen = (manualRun.value || currentRun || "").trim();
      if (!chosen) return;
      currentRun = chosen;
      userSelectedRun = true;
      setRunInUrl(currentRun);
      loadRun(currentRun);
      startAuto();
    };
    if (runSelectBtn) {
      runSelectBtn.onclick = (e) => {
        e.stopPropagation();
        if (runPopover?.classList.contains("open")) closeRunPopover();
        else openRunPopover();
      };
    }
    document.addEventListener("click", (e) => {
      if (!runPopover?.classList.contains("open")) return;
      if (runSelect && runSelect.contains(e.target)) return;
      closeRunPopover();
    });
    if (runFilter) {
      runFilter.oninput = () => {
        const q = runFilter.value.toLowerCase();
        const filtered = runEntries.filter(entry => {
          const row = entry.row || {};
          return `${row.run_id} ${row.input?.pdf || ""} ${row.path || ""}`.toLowerCase().includes(q);
        });
        renderRunOptions(filtered);
      };
    }
    toggleAuto.onclick = () => {
      if (autoTimer) stopAuto(); else startAuto();
    };
    if (showExternal) {
      showExternal.onchange = () => loadManifest();
    }

    // Make H1 clickable to return to base URL (auto-select latest run)
    if (titleH1) {
      titleH1.onclick = () => {
        userSelectedRun = false;
        setRunInUrl(null, true); // Remove run param from URL
        currentRun = null;
        loadManifest().then(() => {
          if (currentRun) {
            loadRun(currentRun);
          }
          startAuto();
        });
      };
    }

    function getRunDurationHtml(state, events) {
      if (!events || !events.length) return "Duration: —";
      const startEvt = events[0];
      const endEvt = events[events.length - 1];
      const start = parseTimestamp(startEvt.timestamp);
      const end = parseTimestamp(endEvt.timestamp);
      if (!start) return "Duration: —";

      const now = Date.now();
      const topStatus = (state.status || "").toLowerCase();
      const endedAt = parseTimestamp(state.ended_at);
      const endTs = isValidTs(endedAt) ? endedAt : end;
      const ago = Math.floor((now - endTs) / 1000);
      let agoStr = "just now";
      if (ago > 0) agoStr = formatDuration(ago) + " ago";
      // Check if run is truly done based on state status OR if all stages are done
      let isDone = topStatus === "done" || topStatus === "failed" || topStatus === "crashed";
      if (!isDone && state.stages) {
        const stages = Object.values(state.stages);
        if (stages.length > 0 && stages.every(s => s.status === "done" || s.status === "failed" || s.status === "skipped")) {
          isDone = true;
        }
      }

      if (isDone) {
        const duration = end - start;
        const durStr = formatDuration(duration / 1000);
        if (topStatus === "failed") {
          return `Failed ${agoStr} (took ${durStr})`;
        }
        if (topStatus === "crashed") {
          return `Crashed ${agoStr} (took ${durStr})`;
        }
        return `Finished ${agoStr} (took ${durStr})`;
      } else {
        // Running
        const duration = now - start;
        const durStr = formatDuration(duration / 1000);
        // Return a span with data attributes for live updates
        return `<span class="live-duration" data-start="${start}">Running for ${durStr}</span>`;
      }
    }

    function updateLiveTimers() {
      document.querySelectorAll(".live-duration").forEach(el => {
        const start = parseInt(el.dataset.start, 10);
        if (!start) return;
        const now = Date.now();
        const duration = (now - start) / 1000;
        el.textContent = `Running for ${formatDuration(duration)}`;
      });
    }

    // Start live timer loop
    if (!liveTimer) {
      liveTimer = setInterval(updateLiveTimers, 1000);
    }

    const runFromUrl = getRunFromUrl();
    if (runFromUrl) {
      currentRun = runFromUrl;
      userSelectedRun = true;
      if (manualRun) manualRun.value = runFromUrl;
    }

    loadManifest().then(() => {
      if (currentRun) {
        loadRun(currentRun);
      }
      startAuto();
    });
  </script>
</body>

</html>
    let runEntries = [];
