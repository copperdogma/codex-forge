<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pipeline Visibility — codex-forge</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=IBM+Plex+Mono:wght@400;600&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/json.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/markdown.min.js"></script>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #131821;
      --panel-2: #182030;
      --accent: #4ad7b2;
      --accent-2: #f5a524;
      --text: #f4f7fb;
      --muted: #8ea0b8;
      --danger: #ff6b6b;
      --grid: 280px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Space Grotesk", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(120% 120% at 20% 20%, rgba(74, 215, 178, 0.08), transparent),
        radial-gradient(120% 120% at 80% 0%, rgba(245, 165, 36, 0.08), transparent),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 20px 32px 0;
    }

    header {
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 18px;
    }

    h1 {
      margin: 0;
      font-size: 26px;
      letter-spacing: -0.01em;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      font-size: 13px;
      color: var(--muted);
    }

    .pill strong {
      color: var(--text);
      font-weight: 600;
    }

    .controls {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 14px;
      padding: 14px 16px;
      display: grid;
      grid-template-columns: 2fr 1fr 1fr auto;
      gap: 12px;
      align-items: end;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.25);
    }

    .controls label {
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.05em;
    }

    .controls input,
    .controls select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.07);
      background: var(--panel-2);
      color: var(--text);
      font-family: "Space Grotesk", sans-serif;
    }

    .controls button {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(135deg, var(--accent), #2ebd9c);
      color: #041115;
      font-weight: 700;
      cursor: pointer;
      letter-spacing: 0.01em;
    }

    .controls button.secondary {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(var(--grid), 1fr));
      gap: 14px;
      margin-top: 16px;
    }

    .card {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .stage-card {
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
      padding-bottom: 42px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .stage-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .stage-name {
      font-weight: 600;
      font-size: 15px;
    }

    .stage-time {
      font-size: 12px;
      color: var(--muted);
      font-family: "IBM Plex Mono", monospace;
    }

    .elapsed {
      font-size: 12px;
      color: var(--muted);
    }

    .elapsed.running {
      color: var(--accent);
    }

    .card h3 {
      margin: 0;
      font-size: 16px;
      letter-spacing: -0.01em;
    }

    .meta {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--muted);
    }

    .progress-bar {
      position: relative;
      height: 10px;
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 999px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-bar span {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      background: linear-gradient(90deg, var(--accent), #6cf0ca);
      border-radius: 999px;
    }

    .status {
      font-size: 13px;
      font-weight: 600;
    }

    .status.running {
      color: var(--accent);
    }

    .status.done {
      color: #8fe3ff;
    }

    .status.failed {
      color: var(--danger);
    }

    .status.skipped {
      color: var(--muted);
    }

    .chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .chip {
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 12px;
      color: var(--muted);
    }

    .chip strong {
      color: var(--text);
    }

    .timeline {
      margin-top: 18px;
    }

    .timeline ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .timeline li {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: grid;
      grid-template-columns: 160px 90px 1fr;
      gap: 10px;
      align-items: center;
    }

    .mono {
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      color: var(--muted);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .badge.success {
      background: rgba(106, 255, 215, 0.16);
      color: #7bf3cc;
      border: 1px solid rgba(106, 255, 215, 0.3);
    }

    .badge.warn {
      background: rgba(245, 165, 36, 0.14);
      color: #f5c36a;
      border: 1px solid rgba(245, 165, 36, 0.3);
    }

    .badge.danger {
      background: rgba(255, 107, 107, 0.18);
      color: #ff9f9f;
      border: 1px solid rgba(255, 107, 107, 0.3);
    }

    .badge.muted {
      background: rgba(255, 255, 255, 0.08);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .footer {
      margin-top: auto;
      padding-bottom: 20px;
      color: var(--muted);
      font-size: 12px;
    }

    .artifact-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .btn-small {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      cursor: pointer;
      font-size: 12px;
    }

    .metrics {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    .stage-help {
      /* removed absolute positioning */
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      font-weight: 700;
      font-family: "Space Grotesk", sans-serif;
      cursor: help;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease, opacity 0.15s ease;
      font-size: 10px;
      margin-left: 8px;
      /* Spacing from title */
      opacity: 0.4;
      position: relative;
      /* For tooltip positioning context */
    }

    .stage-help:hover,
    .stage-help:focus {
      outline: none;
      background: var(--panel-2);
      border-color: rgba(255, 255, 255, 0.22);
      transform: translateY(-1px);
      opacity: 1;
    }

    .stage-help-tooltip {
      display: none;
      position: absolute;
      right: 0;
      bottom: 100%;
      margin-bottom: 8px;
      width: max-content;
      max-width: 400px;
      background: var(--panel-2);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      padding: 10px 12px;
      color: var(--text);
      font-size: 12px;
      text-align: left;
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
      white-space: normal;
      line-height: 1.5;
      z-index: 100;
    }

    .stage-help:hover .stage-help-tooltip,
    .stage-help:focus .stage-help-tooltip {
      display: block;
    }

    /* Fix for left-most tooltips getting cut off */
    .stage-card:nth-child(3n+1) .stage-help-tooltip {
      left: 0;
      right: auto;
    }

    pre {
      background: #0d1219;
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 12px;
      overflow: auto;
      font-family: "IBM Plex Mono", monospace;
      font-size: 12px;
      /* removed max-height to let flex container handle scrolling */
    }

    .layout {
      display: grid;
      grid-template-columns: 1fr 0 0;
      gap: 0;
      transition: grid-template-columns 0.2s ease;
      flex: 1;
      min-height: 0;
      margin-bottom: 16px;
    }

    #split-handle {
      width: 0;
      cursor: col-resize;
      background: rgba(255, 255, 255, 0.06);
    }

    #pane-col {
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
      max-height: 100%;
    }

    #artifact-preview {
      flex: 1;
      overflow: auto;
      margin: 0;
      border-radius: 0 0 14px 14px;
      border-top: none;
      height: 100%;
    }

    .pane-header {
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      margin-bottom: 10px;
    }

    .pane-actions {
      display: flex;
      gap: 6px;
    }

    pre code.hljs {
      display: block;
    }

    @media (max-width: 1100px) {
      .layout {
        grid-template-columns: 1fr 0 0;
      }

      #pane-col {
        position: sticky;
        top: 10px;
      }
    }

    @media (max-width: 900px) {
      .controls {
        grid-template-columns: 1fr;
      }

      .timeline li {
        grid-template-columns: 120px 70px 1fr;
      }
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Pipeline Visibility</h1>
      <div class="pill">Live view of <strong>pipeline_state.json</strong> + events</div>
      <div class="pill" style="font-size:10px; opacity:0.5;">v12-debug</div>
    </div>
    <div class="pill mono" id="last-refresh">—</div>
  </header>

  <section class="controls">
    <div>
      <label for="run-select">Run</label>
      <select id="run-select"></select>
    </div>
    <div>
      <label for="manual-run">Manual Run ID</label>
      <input id="manual-run" placeholder="e.g., deathtrap-text-ingest" />
    </div>
    <div>
      <label for="refresh-ms">Refresh (ms)</label>
      <input type="number" id="refresh-ms" value="4000" min="1000" step="500" />
    </div>
    <div style="display:flex; gap:8px;">
      <button id="load-btn">Load</button>
      <button class="secondary" id="toggle-auto">Pause Auto</button>
    </div>
  </section>

  <div class="layout" id="layout">
    <div id="main-col">
      <section class="grid" id="summary-grid"></section>
      <section class="grid" id="stage-grid"></section>
      <section class="card timeline">
        <h3>Recent Events</h3>
        <ul id="timeline-list"></ul>
      </section>
    </div>
    <div id="split-handle" title="Drag to resize"></div>
    <aside class="card" id="pane-col" style="display:none;">
      <div class="pane-header">
        <h3>Artifact Pane</h3>
        <div class="pane-actions">
          <button class="btn-small" id="pane-open-tab">Open in new tab</button>
          <button class="btn-small" id="pane-close">Close</button>
        </div>
      </div>
      <div class="meta" id="artifact-meta"></div>
      <pre id="artifact-preview"></pre>
    </aside>
  </div>

  <div class="footer">
    Serve this file from the repo root (e.g., <code>python -m http.server 8000</code>) then open
    <code>/docs/pipeline-visibility.html</code>.
    The viewer polls <code>pipeline_state.json</code> and <code>pipeline_events.jsonl</code> inside
    <code>output/runs/&lt;run_id&gt;/</code>.
  </div>

  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/json.min.js"></script>
  <script>
    const ROOT = window.location.pathname.includes("/docs/") ? ".." : ".";
    const runSelect = document.getElementById("run-select");
    const manualRun = document.getElementById("manual-run");
    const loadBtn = document.getElementById("load-btn");
    const toggleAuto = document.getElementById("toggle-auto");
    const refreshInput = document.getElementById("refresh-ms");
    const lastRefresh = document.getElementById("last-refresh");
    const summaryGrid = document.getElementById("summary-grid");
    const stageGrid = document.getElementById("stage-grid");
    const timelineList = document.getElementById("timeline-list");
    const layout = document.getElementById("layout");
    const mainCol = document.getElementById("main-col");
    const splitHandle = document.getElementById("split-handle");
    const artifactPanel = document.getElementById("pane-col");
    const artifactMeta = document.getElementById("artifact-meta");
    const artifactPreview = document.getElementById("artifact-preview");
    const paneClose = document.getElementById("pane-close");
    const paneOpenTab = document.getElementById("pane-open-tab");

    let currentRun = null;
    let userSelectedRun = false;
    let autoTimer = null;
    let liveTimer = null;
    const artifactCache = {};
    const instCache = {};
    const runMeta = {};

    const statusDescriptors = {
      "running": { text: "Running", class: "running" },
      "done": { text: "Done", class: "done" },
      "failed": { text: "Failed", class: "failed" },
      "skipped": { text: "Skipped", class: "skipped" },
      "queued": { text: "Queued", class: "muted" }
    };

    function artifactUrl(artifact, base) {
      if (!artifact) return null;
      if (/^https?:\/\//.test(artifact)) return artifact;          // absolute
      if (artifact.startsWith(ROOT + "/")) return artifact;        // already rooted
      if (artifact.startsWith("output/")) return `${ROOT}/${artifact}`; // repo-relative
      if (base) return `${base}/${artifact}`;                      // relative to run base
      return `${ROOT}/${artifact}`;
    }

    function escapeHtml(str) {
      return str.replace(/[&<>'"]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }[c]));
    }

    function renderPretty(text, lang = "json") {
      const code = document.createElement("code");
      code.className = `language-${lang}`;
      code.textContent = text; // safer than innerHTML
      artifactPreview.innerHTML = "";
      const pre = document.createElement("pre");
      pre.appendChild(code);
      artifactPreview.appendChild(pre);
      if (window.hljs) {
        // small delay to ensure DOM is ready if needed, though usually immediate is fine
        requestAnimationFrame(() => {
          try { hljs.highlightElement(code); } catch (e) { console.error(e); }
        });
      }
    }

    function openPane() {
      artifactPanel.style.display = "block";
      layout.style.gridTemplateColumns = "1fr 6px min(45vw, 640px)";
      splitHandle.style.width = "6px";
    }

    function closePane() {
      artifactPanel.style.display = "none";
      layout.style.gridTemplateColumns = "1fr 0 0";
      splitHandle.style.width = "0";
    }

    paneClose.onclick = () => closePane();
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closePane();
    });
    paneOpenTab.onclick = () => {
      const path = paneOpenTab.dataset.path;
      const stage = paneOpenTab.dataset.stage;
      if (path) openArtifactTab(stage || "", path);
    };

    let dragging = false;
    splitHandle.addEventListener("mousedown", () => { dragging = true; });
    window.addEventListener("mouseup", () => { dragging = false; });
    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const total = layout.getBoundingClientRect();
      const mainWidth = e.clientX - total.left;
      const paneWidth = Math.max(280, total.width - mainWidth - 6);
      layout.style.gridTemplateColumns = `${Math.max(320, mainWidth)}px 6px ${paneWidth}px`;
    });

    function parseJSONL(text) {
      return text.split("\n").filter(Boolean).map(line => {
        try { return JSON.parse(line); } catch { return null; }
      }).filter(Boolean);
    }

    async function fetchJSON(path) {
      const res = await fetch(path + "?t=" + Date.now());
      if (!res.ok) throw new Error(`Fetch failed: ${path}`);
      return res.json();
    }
    async function fetchJSONL(path) {
      const res = await fetch(path + "?t=" + Date.now());
      if (!res.ok) throw new Error(`Fetch failed: ${path}`);
      const text = await res.text();
      return parseJSONL(text);
    }

    function parseTimestamp(val) {
      if (!val) return 0;
      // Trim fractional seconds to 3 digits for JS Date.parse compatibility
      const fixed = val.replace(/\\.(\\d{3})\\d+Z$/, ".$1Z");
      const ts = Date.parse(fixed);
      return isNaN(ts) ? 0 : ts;
    }

    async function loadManifest() {
      const manifestPath = `${ROOT}/output/run_manifest.jsonl`;
      try {
        const res = await fetch(manifestPath);
        if (!res.ok) throw new Error();
        const lines = parseJSONL(await res.text());
        runSelect.innerHTML = "";

        const candidates = lines.slice(-150); // last N entries

        async function resolveTs(row) {
          // Try to parse timestamp from run_id (e.g. ...20251124e)
          const dateMatch = row.run_id.match(/(\d{8})([a-z]?)$/);
          if (dateMatch) {
            const dStr = dateMatch[1];
            const suffix = dateMatch[2] || "";
            // approximate time: date + suffix offset
            const y = dStr.slice(0, 4), m = dStr.slice(4, 6), d = dStr.slice(6, 8);
            let ts = new Date(`${y}-${m}-${d}T00:00:00Z`).getTime();
            if (suffix) ts += (suffix.charCodeAt(0) - 96) * 1000; // a=1s, b=2s...
            return ts;
          }

          const direct = parseTimestamp(row.created_at || row.updated_at || "");
          if (direct) return direct;
          if (!row.path) return 0;
          try {
            const state = await fetchJSON(`${ROOT}/${row.path}/pipeline_state.json`);
            let ts = parseTimestamp(state.updated_at || state.created_at || state.timestamp || "");
            if (!ts && state.stages) {
              const stageTimes = Object.values(state.stages).map(s => parseTimestamp(s.updated_at));
              const maxStage = Math.max(0, ...stageTimes.filter(Boolean));
              ts = maxStage;
            }
            return ts;
          } catch {
            return 0;
          }
        }

        const withTs = await Promise.all(candidates.map(async (row) => ({
          row,
          ts: await resolveTs(row),
        })));

        const sorted = withTs.sort((a, b) => (b.ts || 0) - (a.ts || 0)).map(x => x.row);

        // reverse for display so newest is first in dropdown
        sorted.forEach(row => {
          runMeta[row.run_id] = row;
          const opt = document.createElement("option");
          opt.value = row.run_id;
          opt.textContent = `${row.run_id} — ${row.input?.pdf || row.path}`;
          runSelect.appendChild(opt);
        });
        const currentExists = sorted.some(r => r.run_id === currentRun);
        if (!userSelectedRun || !currentExists) {
          currentRun = sorted.length ? sorted[0].run_id : null; // newest
        }
        if (currentRun) runSelect.value = currentRun;
        lastRefresh.textContent = `Manifest: ${manifestPath}`;
      } catch {
        runSelect.innerHTML = "";
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No manifest found (add run manually)";
        runSelect.appendChild(opt);
      }
    }

    function percentText(p) {
      if (p === null || p === undefined) return "—";
      return `${p}%`;
    }

    function formatDuration(seconds) {
      if (seconds == null || isNaN(seconds) || seconds < 0) return "—";
      if (seconds < 1) return "<1s";
      const s = Math.floor(seconds % 60);
      const m = Math.floor((seconds / 60) % 60);
      const h = Math.floor(seconds / 3600);
      if (h) return `${h}h ${m.toString().padStart(2, "0")}m`;
      return `${m}:${s.toString().padStart(2, "0")}s`;
    }

    function computeStageDurations(events, stages) {
      const map = {};
      const byStage = {};

      // Group events by stage
      const MIN_VALID_TS = new Date("2025-01-01").getTime();
      events.forEach(evt => {
        if (!evt.stage) return;
        const ts = parseTimestamp(evt.timestamp);
        if (!ts || ts < MIN_VALID_TS) return;

        if (!byStage[evt.stage]) byStage[evt.stage] = [];
        byStage[evt.stage].push(evt);
      });

      Object.keys(byStage).forEach(stage => {
        const stageEvents = byStage[stage];
        // Sort by timestamp string
        stageEvents.sort((a, b) => (a.timestamp || "").localeCompare(b.timestamp || ""));

        let totalDuration = 0;
        let runCount = 0;
        let sessionStart = null;
        let lastTs = 0;
        const GAP_THRESHOLD = 15 * 60 * 1000; // 15 mins

        stageEvents.forEach((evt, idx) => {
          const ts = parseTimestamp(evt.timestamp);
          if (!ts) return;

          let isNewSession = false;
          if (lastTs && (ts - lastTs > GAP_THRESHOLD)) {
            isNewSession = true;
          }

          if (isNewSession) {
            // End previous session
            if (sessionStart !== null) {
              totalDuration += (lastTs - sessionStart);
              runCount++;
              sessionStart = null;
            }
          }

          // Start new session if needed
          if (sessionStart === null) {
            sessionStart = ts;
          }

          // If this is the last event, close the session
          if (idx === stageEvents.length - 1) {
            if (sessionStart !== null) {
              totalDuration += (ts - sessionStart);
              runCount++;
            }
          }

          lastTs = ts;
        });

        // If totalDuration is 0 but we have events, maybe it was instantaneous?
        // Or maybe we just have one event?
        // If we have >0 events, runCount should be at least 1.
        if (runCount === 0 && stageEvents.length > 0) runCount = 1;

        map[stage] = {
          totalDuration,
          runCount,
          lastStatus: stageEvents[stageEvents.length - 1].status,
          // Keep start/end for compatibility if needed, but UI should use totalDuration
          start: stageEvents[0] ? parseTimestamp(stageEvents[0].timestamp) : null,
          end: stageEvents[stageEvents.length - 1] ? parseTimestamp(stageEvents[stageEvents.length - 1].timestamp) : null
        };

        if (stage === "build") {
          console.log("Build map entry:", map[stage]);
        }
      });

      // fallbacks from state updated_at when no events
      Object.entries(stages || {}).forEach(([stage, info]) => {
        if (map[stage]) return;
        const ts = parseTimestamp(info.updated_at);
        if (ts) map[stage] = { totalDuration: 0, runCount: 1, lastStatus: info.status, start: ts, end: ts };
      });
      return map;
    }

    function summariseStages(stages) {
      const entries = Object.entries(stages || {});
      const done = entries.filter(([, s]) => s.status === "done").length;
      const failed = entries.filter(([, s]) => s.status === "failed").length;
      const running = entries.filter(([, s]) => s.status === "running").length;
      const percents = entries.map(([, s]) => (s.progress && s.progress.percent != null ? s.progress.percent : (s.status === "done" ? 100 : 0)));
      const avg = percents.length ? Math.round(percents.reduce((a, b) => a + b, 0) / percents.length) : 0;
      return { done, failed, running, avg, total: entries.length };
    }

    function badge(status) {
      const span = document.createElement("span");
      const desc = statusDescriptors[status] || { text: status || "unknown", class: "muted" };
      span.className = `badge ${desc.class}`;
      span.textContent = desc.text.toUpperCase();
      return span;
    }

    async function loadRun(runId) {
      if (!runId) return;
      currentRun = runId;
      const meta = runMeta[runId] || {};
      const base = meta.path ? `${ROOT}/${meta.path}` : `${ROOT}/output/runs/${runId}`;
      try {
        const instPath = meta.instrumentation?.json
          ? `${ROOT}/${meta.instrumentation.json}`
          : `${base}/instrumentation.json`;
        const [state, events, instrumentation] = await Promise.all([
          fetchJSON(`${base}/pipeline_state.json`),
          fetchJSONL(`${base}/pipeline_events.jsonl`).catch(() => []),
          fetchJSON(instPath).catch(() => null)
        ]);
        if (instrumentation) instCache[runId] = instrumentation;
        render(state, events, base, instCache[runId]);
        lastRefresh.textContent = `Updated ${new Date().toLocaleTimeString()}`;
      } catch (e) {
        stageGrid.innerHTML = "";
        summaryGrid.innerHTML = "";
        timelineList.innerHTML = `<li class="mono">Unable to load run "${runId}". Check that output/runs/${runId}/pipeline_state.json exists.</li>`;
      }
    }

    function render(state, events, base, instrumentation) {
      const stages = state.stages || {};
      const stats = summariseStages(stages);
      const meta = runMeta[state.run_id || currentRun] || {};
      // Resolve input artifact (pdf, images_dir, etc.)
      const inputMeta = meta.input || {};
      let inputPath = null;
      let inputLabel = "Input";
      const toAbs = (p) => {
        if (!p) return null;
        if (/^https?:\/\//.test(p)) return p;
        if (p.startsWith(ROOT + "/")) return p;
        return `${ROOT}/${p}`;
      };
      if (inputMeta.pdf) {
        inputPath = toAbs(inputMeta.pdf);
        inputLabel = "Input PDF";
      } else if (inputMeta.images_dir) {
        inputPath = toAbs(inputMeta.images_dir);
        inputLabel = "Input images";
      } else if (inputMeta.images) {
        const p = Array.isArray(inputMeta.images) ? inputMeta.images[0] : inputMeta.images;
        inputPath = toAbs(p);
        inputLabel = "Input images";
      } else if (inputMeta.text_glob) {
        inputPath = toAbs(inputMeta.text_glob);
        inputLabel = "Input text";
      }
      const finalArtifact = findFinalArtifact(stages);

      summaryGrid.innerHTML = "";
      summaryGrid.appendChild(makeStatCard("Overall Progress", `${stats.avg}%`, [
        `${stats.done}/${stats.total} done`,
        `${stats.running} running`,
        `${stats.failed} failed`,
        getRunDurationHtml(state, events)
      ]));
      summaryGrid.appendChild(makeStatCard("Run", state.run_id || currentRun || "n/a", [
        state.updated_at ? `updated ${state.updated_at}` : "live",
        base.replace(`${ROOT}/`, "")
      ]));
      summaryGrid.appendChild(makeStatCard("Artifacts", "", [
        inputPath
          ? `<button class="btn-small" onclick="window.open('${inputPath}', '_blank')">${inputLabel}</button>`
          : "Input artifact unknown",
        finalArtifact
          ? `<button class="btn-small" onclick="openArtifactTab('final', '${ROOT}/${finalArtifact}')">Final JSON</button>`
          : "Final artifact not detected",
        "Click any stage to open artifacts"
      ]));

      // Debug Card
      const debugCard = document.createElement("div");
      debugCard.className = "card";
      debugCard.innerHTML = `<h3>Debug Info</h3><button class="btn-small" onclick="const el=document.getElementById('debug-details'); el.style.display=el.style.display==='none'?'block':'none'">Toggle Details</button><div id="debug-details" style="display:none; margin-top:10px; font-family:monospace; font-size:10px; white-space:pre-wrap;"></div>`;
      summaryGrid.appendChild(debugCard);
      const inst = document.createElement("div");
      inst.className = "card";
      inst.innerHTML = `<h3>Instrumentation</h3>`;
      const links = document.createElement("div");
      links.className = "meta";
      if (meta.instrumentation?.json) {
        const btn = document.createElement("button");
        btn.className = "btn-small";
        btn.onclick = () => window.open(`${ROOT}/${meta.instrumentation.json}`, '_blank');
        btn.textContent = "JSON report";
        links.appendChild(btn);
      }
      if (meta.instrumentation?.md) {
        const btn = document.createElement("button");
        btn.className = "btn-small";
        btn.onclick = () => openArtifactTab("Instrumentation", `${ROOT}/${meta.instrumentation.md}`);
        btn.textContent = "Markdown summary";
        links.appendChild(btn);
      }
      if (instrumentation) {
        const totals = instrumentation.totals || {};
        const perModel = totals.per_model || {};
        const models = Object.entries(perModel).sort((a, b) => (b[1].cost || 0) - (a[1].cost || 0)).slice(0, 3);
        const stats = document.createElement("div");
        stats.className = "meta";
        stats.innerHTML = `
          <span>Total cost: ${(totals.cost || 0).toFixed(4)} ${(instrumentation.pricing?.currency) || "USD"}</span>
          <span>Calls: ${totals.calls || 0}</span>
          <span>Tokens: ${totals.prompt_tokens || 0} / ${totals.completion_tokens || 0}</span>
        `;
        inst.appendChild(stats);
        if (models.length) {
          const top = document.createElement("div");
          top.className = "meta";
          top.innerHTML = `<span>Top models:</span>${models.map(([m, v]) => `<span>${m}: ${(v.cost || 0).toFixed(4)}</span>`).join("")}`;
          inst.appendChild(top);
        }
      } else {
        const msg = document.createElement("div");
        msg.className = "meta";
        msg.innerHTML = "<span>Instrumentation data not found for this run.</span>";
        inst.appendChild(msg);
      }
      if (links.children.length) inst.appendChild(links);
      summaryGrid.appendChild(inst);

      const durations = computeStageDurations(events, stages);
      renderStages(stages, events, base, instrumentation, durations);
      renderTimeline(events);
    }

    function makeStatCard(title, value, lines) {
      const card = document.createElement("div");
      card.className = "card";
      card.innerHTML = `<h3>${title}</h3><div class="status done" style="font-size:24px;">${value}</div>`;
      if (lines?.length) {
        const ul = document.createElement("div");
        ul.className = "meta";
        lines.forEach(l => {
          const span = document.createElement("span");
          const content = (typeof l === "string") ? l : (l?.html ?? l);
          if (typeof content === "string" && content.includes("<")) {
            span.innerHTML = content;
            span.querySelectorAll("a").forEach(a => {
              if (!a.target) a.target = "_blank";
              a.rel = "noreferrer noopener";
            });
          } else {
            span.textContent = content ?? "";
          }
          ul.appendChild(span);
        });
        card.appendChild(ul);
      }
      return card;
    }

    function renderStages(stages, events, base, instrumentation, durations) {
      stageGrid.innerHTML = "";
      const instMap = {};
      if (instrumentation?.stages) {
        instrumentation.stages.forEach(s => { if (s.id) instMap[s.id] = s; });
      }
      const stageEntries = Object.entries(stages || {}).filter(([_, info]) => info?.module_id || info?.description);
      const ordered = stageEntries.map(([k]) => k).sort((a, b) => {
        const startA = durations?.[a]?.start || 0;
        const startB = durations?.[b]?.start || 0;
        if (startA !== startB) return startA - startB;
        return a.localeCompare(b);
      });
      console.log('Ordered stages:', ordered);

      const debugDetails = document.getElementById('debug-details');
      if (debugDetails) {
        debugDetails.textContent = ordered.map(s => {
          const d = durations[s];
          const durSec = d ? (d.totalDuration / 1000).toFixed(1) : "N/A";
          return `${s.padEnd(20)}: ${durSec}s (${d?.runCount || 0} runs)`;
        }).join('\n');
      }

      ordered.forEach(stage => {
        console.log(`Rendering stage: ${stage}`, stages[stage], durations[stage]);
        const dur = durations[stage];
        const info = stages[stage];
        const card = document.createElement("div");
        card.className = "card stage-card";
        const status = info.status || "queued";
        const prog = info.progress || {};

        const elapsed = dur ? formatDuration(dur.totalDuration / 1000) : "—";
        const runCountText = (dur && dur.runCount > 1) ? ` • ${dur.runCount} RUNS` : "";

        card.innerHTML = `
      <div class="stage-header">
        <span class="stage-name">${stage}</span>
        <span class="stage-time" style="margin-left:auto;">⏱ ${elapsed}</span>
      </div>
      <div class="status ${statusDescriptors[status]?.class || ""}">${status.toUpperCase()}${runCountText}</div>
      <div class="progress-bar"><span style="width:${Math.min(100, prog.percent || (status === "done" ? 100 : 0))}%"></span></div>
      <div class="meta">
        <span>${prog.current ?? "—"} / ${prog.total ?? "?"}</span>
        <span>${percentText(prog.percent)}</span>
        <span>${info.updated_at || ""}</span>
      </div>
    `;

        const chips = document.createElement("div");
        chips.className = "chips";
        if (info.artifact) {
          const name = info.artifact.split("/").slice(-1)[0];
          const artChip = document.createElement("div");
          artChip.className = "chip";
          artChip.innerHTML = `<strong>Artifact</strong> ${name}`;
          chips.appendChild(artChip);
        }
        if (info.module_id) {
          const mod = document.createElement("div");
          mod.className = "chip";
          mod.innerHTML = `<strong>Module</strong> ${info.module_id}`;
          chips.appendChild(mod);
        }
        if (info.schema_version) {
          const sch = document.createElement("div");
          sch.className = "chip";
          sch.innerHTML = `<strong>Schema</strong> ${info.schema_version}`;
          chips.appendChild(sch);
        }
        const inst = instMap[stage];
        const description = info.description || inst?.description || (info.module_id
          ? `Stage ${stage} runs module ${info.module_id} (description not recorded yet).`
          : "Description not recorded for this stage yet.");
        const costVal = inst?.llm_totals?.cost || 0;
        const costChip = document.createElement("div");
        costChip.className = "chip";
        costChip.title = costVal === 0 ? "No LLM calls recorded for this stage (non-LLM step or module emitted no usage)" : "";
        costChip.innerHTML = `<strong>Cost</strong> ${costVal.toFixed(4)}`;
        chips.appendChild(costChip);
        if (inst && inst.wall_seconds != null) {
          const timeChip = document.createElement("div");
          timeChip.className = "chip";
          timeChip.innerHTML = `<strong>Wall</strong> ${inst.wall_seconds.toFixed(2)}s`;
          chips.appendChild(timeChip);
        }
        card.appendChild(chips);

        const actions = document.createElement("div");
        actions.className = "artifact-actions";
        if (info.artifact) {
          const open = document.createElement("button");
          open.className = "btn-small";
          open.textContent = "Open artifact (new tab)";
          open.onclick = () => openArtifactTab(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(open);

          const viewBtn = document.createElement("button");
          viewBtn.className = "btn-small";
          viewBtn.textContent = "View in pane";
          viewBtn.onclick = () => viewArtifact(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(viewBtn);

          const metricsBtn = document.createElement("button");
          metricsBtn.className = "btn-small";
          metricsBtn.textContent = "Load metrics";
          metricsBtn.onclick = () => loadMetrics(stage, `${ROOT}/${info.artifact}`);
          actions.appendChild(metricsBtn);
        }
        const history = events.filter(e => e.stage === stage);
        if (history.length) {
          const last = history[history.length - 1];
          const hint = document.createElement("div");
          hint.className = "metrics";
          // Trim milliseconds: "2025-11-26T15:45:01.123456Z" -> "2025-11-26T15:45:01Z"
          const cleanTs = (last.timestamp || "").replace(/\.\d+Z$/, "Z");
          hint.textContent = `${history.length} events | last: ${last.status} @ ${cleanTs}`;
          actions.appendChild(hint);
        }

        if (description) {
          const help = document.createElement("button");
          help.className = "stage-help";
          help.type = "button";
          help.setAttribute("aria-label", `What ${stage} does`);
          help.textContent = "?";
          const tip = document.createElement("div");
          tip.className = "stage-help-tooltip";
          tip.textContent = description;
          help.appendChild(tip);

          // Append to stage name container
          const header = card.querySelector(".stage-header");
          const nameEl = header ? header.querySelector(".stage-name") : null;
          if (nameEl) {
            // Insert after the stage name
            nameEl.after(help);
          }
        }
        card.appendChild(actions);
        stageGrid.appendChild(card);
      });
    }

    function renderTimeline(events) {
      timelineList.innerHTML = "";
      const recent = events.slice(-80).reverse();
      if (!recent.length) {
        timelineList.innerHTML = `<li class="mono">No events yet for this run.</li>`;
        return;
      }
      recent.forEach(evt => {
        const li = document.createElement("li");
        const badgeEl = badge(evt.status);
        const stage = document.createElement("div");
        stage.innerHTML = `<strong>${evt.stage}</strong><br><span class="mono">${evt.timestamp}</span>`;
        const prog = evt.percent != null ? `${evt.current || "?"}/${evt.total || "?"} (${evt.percent}%)` : "";
        const msg = document.createElement("div");
        msg.innerHTML = `<div class="mono">${prog}</div><div>${evt.message || ""}</div>`;
        const col1 = document.createElement("div");
        col1.appendChild(stage);
        const col2 = document.createElement("div");
        col2.appendChild(badgeEl);
        li.appendChild(stage);
        li.appendChild(col2);
        li.appendChild(msg);
        timelineList.appendChild(li);
      });
    }

    async function loadMetrics(stage, artifactPath) {
      openPane();
      artifactMeta.innerHTML = "";
      artifactPreview.textContent = "Loading…";
      paneOpenTab.dataset.path = artifactPath;
      paneOpenTab.dataset.stage = stage;

      if (artifactCache[artifactPath]) {
        renderMetrics(stage, artifactPath, artifactCache[artifactPath]);
        return;
      }

      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();
        let rows = [];
        const lowerPath = artifactPath.toLowerCase();
        if (lowerPath.endsWith(".jsonl")) {
          rows = parseJSONL(text);
        } else if (lowerPath.endsWith(".json")) {
          rows = Object.values(JSON.parse(text));
        }
        const confidences = rows.map(r => r.confidence).filter(v => v !== undefined && v !== null);
        const avg = confidences.length ? (confidences.reduce((a, b) => a + b, 0) / confidences.length).toFixed(3) : "n/a";
        const min = confidences.length ? Math.min(...confidences).toFixed(3) : "n/a";
        const max = confidences.length ? Math.max(...confidences).toFixed(3) : "n/a";
        const sample = rows.slice(0, 3);
        const metrics = { count: rows.length, avg, min, max, sample };
        artifactCache[artifactPath] = metrics;
        renderMetrics(stage, artifactPath, metrics);
      } catch (e) {
        artifactPreview.textContent = `Failed to load artifact: ${e.message}`;
      }
    }

    async function openArtifactTab(stage, artifactPath) {
      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();

        const pretty = formatMaybeJSON(text, artifactPath);
        const isMd = artifactPath.toLowerCase().endsWith(".md");
        const isJson = artifactPath.toLowerCase().endsWith(".json") || artifactPath.toLowerCase().endsWith(".jsonl");

        let highlightedCode = "";
        if (window.hljs) {
          if (isJson) {
            try {
              highlightedCode = hljs.highlight(pretty, { language: 'json' }).value;
            } catch (e) {
              console.warn("Highlight error", e);
              highlightedCode = escapeHtml(pretty);
            }
          } else if (isMd) {
            try {
              highlightedCode = hljs.highlight(pretty, { language: 'markdown' }).value;
            } catch (e) {
              highlightedCode = escapeHtml(pretty);
            }
          } else {
            highlightedCode = escapeHtml(pretty);
          }
        } else {
          highlightedCode = escapeHtml(pretty);
        }

        const win = window.open("", "_blank");
        if (!win) {
          alert("Please allow popups to view artifacts in a new tab.");
          return;
        }

        const html = `<!DOCTYPE html><html><head><title>${stage} artifact</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/atom-one-dark.min.css"><style>body{margin:0;background:#0d1219;color:#e5e9f0;padding:20px;}pre{margin:0;white-space:pre-wrap;word-wrap:break-word;}</style></head><body><pre><code class="hljs">${highlightedCode}</code></pre></body></html>`;

        win.document.open();
        win.document.write(html);
        win.document.close();
      } catch (e) {
        alert(`Failed to open artifact: ${e.message}`);
      }
    }

    function formatMaybeJSON(text, artifactPath) {
      try {
        const lower = artifactPath.toLowerCase();
        if (lower.endsWith(".jsonl")) {
          const rows = parseJSONL(text);
          return JSON.stringify(rows, null, 2);
        }
        if (lower.endsWith(".json")) {
          return JSON.stringify(JSON.parse(text), null, 2);
        }
      } catch (e) {
        console.warn("Formatting failed, falling back to raw text", e);
        // fall through to raw text
      }
      return text;
    }

    function getStageInstrumentation(stage) {
      const inst = instCache[currentRun];
      if (!inst?.stages) return null;
      return inst.stages.find(s => s.id === stage);
    }

    async function viewArtifact(stage, artifactPath) {
      openPane();
      artifactPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      const inst = getStageInstrumentation(stage);
      const chips = [
        `<div class="chip"><strong>Stage</strong> ${stage}</div>`,
        `<div class="chip"><strong>Path</strong> ${artifactPath}</div>`
      ];
      if (inst) {
        chips.push(`<div class="chip"><strong>Cost</strong> ${(inst.llm_totals?.cost || 0).toFixed(4)}</div>`);
        chips.push(`<div class="chip"><strong>Calls</strong> ${inst.llm_totals?.calls || 0}</div>`);
        chips.push(`<div class="chip"><strong>Tokens</strong> ${inst.llm_totals?.prompt_tokens ||
          0}/${inst.llm_totals?.completion_tokens || 0}</div>`);
        if (inst.wall_seconds != null) {
          chips.push(`<div class="chip"><strong>Wall</strong> ${inst.wall_seconds.toFixed(2)}s</div>`);
        }
      } else {
        chips.push(`<div class="chip"><strong>Instrumentation</strong> not available</div>`);
      }
      artifactMeta.innerHTML = chips.join("");
      artifactPreview.textContent = "Loading artifact…";
      paneOpenTab.dataset.path = artifactPath;
      paneOpenTab.dataset.stage = stage;

      try {
        const res = await fetch(artifactPath + "?t=" + Date.now());
        if (!res.ok) throw new Error("Unable to fetch artifact");
        const text = await res.text();
        let parsed;
        const lower = artifactPath.toLowerCase();
        if (lower.endsWith(".jsonl")) {
          parsed = parseJSONL(text);
        } else if (lower.endsWith(".json")) {
          parsed = JSON.parse(text);
        } else {
          parsed = text;
        }

        const MAX_ROWS = 200;
        let displayVal = parsed;
        let clipped = false;
        if (Array.isArray(parsed) && parsed.length > MAX_ROWS) {
          displayVal = parsed.slice(0, MAX_ROWS);
          clipped = true;
        }
        const pretty = typeof displayVal === "string" ? displayVal : JSON.stringify(displayVal, null, 2);
        renderPretty(pretty, "json");
        if (clipped) {
          artifactPreview.innerHTML += `<div class="mono">… clipped to first ${MAX_ROWS} records …</div>`;
        }
      } catch (e) {
        artifactPanel.style.display = "block";
        artifactPreview.textContent = `Failed to load artifact: ${e.message}`;
      }
    }

    function renderMetrics(stage, artifactPath, metrics) {
      artifactMeta.innerHTML = `
<div class="chip"><strong>Stage</strong> ${stage}</div>
<div class="chip"><strong>Records</strong> ${metrics.count}</div>
<div class="chip"><strong>Confidence</strong> avg ${metrics.avg}, min ${metrics.min}, max ${metrics.max}</div>
<div class="chip"><strong>Path</strong> ${artifactPath}</div>
`;
      const sample = metrics.sample ?? [];
      const preview = {
        sample: sample,
        note: sample.length === metrics.count ? "full dataset preview" : `showing ${sample.length} of ${metrics.count} records`
      };
      renderPretty(JSON.stringify(preview, null, 2), "json");
    }

    function findFinalArtifact(stages) {
      if (!stages) return null;
      const entries = Object.entries(stages);
      // Prefer confirm/dispatch outputs first
      const preferredOrder = ["confirm_plan", "dispatch", "dispatch_hint", "gap_analysis", "zoom_refine", "overview_plan"];
      for (const id of preferredOrder) {
        if (stages[id]?.artifact) return stages[id].artifact;
      }
      // Otherwise pick most recent done stage with an artifact
      const doneWithArtifact = entries
        .filter(([, v]) => v.artifact)
        .sort((a, b) => parseTimestamp(b[1].updated_at) - parseTimestamp(a[1].updated_at));
      return doneWithArtifact.length ? doneWithArtifact[0][1].artifact : null;
    }

    function startAuto() {
      stopAuto();
      const ms = Number(refreshInput.value) || 4000;
      autoTimer = setInterval(() => {
        if (currentRun) loadRun(currentRun);
      }, ms);
      toggleAuto.textContent = "Pause Auto";
    }
    function stopAuto() {
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = null;
      toggleAuto.textContent = "Resume Auto";
    }

    loadBtn.onclick = () => {
      const chosen = manualRun.value || runSelect.value;
      loadRun(chosen);
      startAuto();
    };
    runSelect.onchange = () => {
      userSelectedRun = true;
      loadRun(runSelect.value);
    };
    toggleAuto.onclick = () => {
      if (autoTimer) stopAuto(); else startAuto();
    };

    function getRunDurationHtml(state, events) {
      if (!events || !events.length) return "Duration: —";
      const startEvt = events[0];
      const endEvt = events[events.length - 1];
      const start = parseTimestamp(startEvt.timestamp);
      const end = parseTimestamp(endEvt.timestamp);
      if (!start) return "Duration: —";

      const now = Date.now();
      // Check if run is truly done based on state status OR if all stages are done
      let isDone = (state.status || "").toLowerCase() === "done" || (state.status || "").toLowerCase() === "failed";
      if (!isDone && state.stages) {
        const stages = Object.values(state.stages);
        if (stages.length > 0 && stages.every(s => s.status === "done" || s.status === "failed" || s.status === "skipped")) {
          isDone = true;
        }
      }

      if (isDone) {
        const duration = end - start;
        const durStr = formatDuration(duration / 1000);
        const ago = Math.floor((now - end) / 1000);
        let agoStr = "just now";
        if (ago > 0) agoStr = formatDuration(ago) + " ago";
        return `Finished ${agoStr} (took ${durStr})`;
      } else {
        // Running
        const duration = now - start;
        const durStr = formatDuration(duration / 1000);
        // Return a span with data attributes for live updates
        return `<span class="live-duration" data-start="${start}">Running for ${durStr}</span>`;
      }
    }

    function updateLiveTimers() {
      document.querySelectorAll(".live-duration").forEach(el => {
        const start = parseInt(el.dataset.start, 10);
        if (!start) return;
        const now = Date.now();
        const duration = (now - start) / 1000;
        el.textContent = `Running for ${formatDuration(duration)}`;
      });
    }

    // Start live timer loop
    if (!liveTimer) {
      liveTimer = setInterval(updateLiveTimers, 1000);
    }

    loadManifest().then(() => {
      if (currentRun) {
        loadRun(currentRun);
      }
      startAuto();
    });
  </script>
</body>

</html>