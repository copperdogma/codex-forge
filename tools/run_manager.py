import argparse
import os
import sys
import yaml
from typing import Optional

# Add project root to sys.path if running from within tools/
if "tools" in os.path.dirname(__file__):
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from schemas import RunConfig, ExecutionConfig, OptionsConfig, InstrumentationConfig

def create_run(name: str):
    """Generates a template run config file."""
    run_dir = os.path.join("output", "runs", name)
    if not os.path.exists(run_dir):
        os.makedirs(run_dir)
        
    path = os.path.join(run_dir, "config.yaml")
    if os.path.exists(path):
        print(f"Error: {path} already exists.")
        sys.exit(1)
        
    # Create a default RunConfig with some placeholders/examples
    config = RunConfig(
        run_id=os.path.splitext(name)[0],
        output_dir=run_dir,
        recipe="configs/recipes/recipe-ff.yaml",
        input_pdf="input/06 deathtrap dungeon.pdf",
        execution=ExecutionConfig(skip_done=True),
        options=OptionsConfig(allow_run_id_reuse=True),
        instrumentation=InstrumentationConfig(enabled=True)
    )
    
    # We want to dump it in a clean YAML format
    # Pydantic's dict() followed by yaml.dump is easiest
    config_dict = config.model_dump(exclude_none=True)
    
    with open(path, "w", encoding="utf-8") as f:
        f.write("# Run Configuration Template\n")
        f.write("# Generated by run_manager.py\n\n")
        yaml.dump(config_dict, f, sort_keys=False, indent=2)
        
    print(f"Created run configuration: {path}")

def execute_run(name: str, extra_args: Optional[list] = None):
    """Validates and executes a run configuration."""
    if not name.endswith(".yaml"):
        # Check if it's a directory in output/runs
        folder_path = os.path.join("output", "runs", name)
        if os.path.isdir(folder_path):
            path = os.path.join(folder_path, "config.yaml")
        else:
            path = name # Fallback to direct path
    else:
        path = name

    if not os.path.exists(path):
        # Maybe they just gave the run name and we should look in output/runs/<name>/config.yaml
        alt_path = os.path.join("output", "runs", name.replace(".yaml", ""), "config.yaml")
        if os.path.exists(alt_path):
            path = alt_path
        else:
            print(f"Error: Config file {path} (or {alt_path}) not found.")
            sys.exit(1)
            
    with open(path, "r", encoding="utf-8") as f:
        config_data = yaml.safe_load(f)
        
    try:
        config = RunConfig(**config_data)
        print(f"Config for '{config.run_id}' validated successfully.")
    except Exception as e:
        print(f"Validation Error in {path}:")
        print(e)
        sys.exit(1)
        
    # Build the driver.py command
    cmd = [sys.executable, "driver.py", "--config", path]
    if extra_args:
        cmd.extend(extra_args)
        
    print(f"Executing: {' '.join(cmd)}")
    sys.stdout.flush()
    os.execvp(sys.executable, cmd)

def main():
    parser = argparse.ArgumentParser(description="Manage pipeline runs.")
    subparsers = parser.add_subparsers(dest="command", help="Commands")
    
    # create-run
    create_parser = subparsers.add_parser("create-run", help="Create a new run configuration template.")
    create_parser.add_argument("name", help="Name of the run (e.g., smoke-test)")
    
    # execute-run
    exec_parser = subparsers.add_parser("execute-run", help="Execute a run configuration.")
    exec_parser.add_argument("name", help="Name or path of the run configuration file.")
    # Allow extra args to be passed to driver.py
    exec_parser.add_argument("extra", nargs=argparse.REMAINDER, help="Additional arguments for driver.py")
    
    args = parser.parse_args()
    
    if args.command == "create-run":
        create_run(args.name)
    elif args.command == "execute-run":
        execute_run(args.name, args.extra)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
